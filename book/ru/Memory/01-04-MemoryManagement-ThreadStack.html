<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>.NET Platform Architecture</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <style>
        body {
    padding: 60px 60px 60px 100px;
}

p, li {
    margin: 0 0 14px;
    font-family: PF Regal,PF Regal Text Pro,Georgia,serif;
    font-size: 20px;
    line-height: 32px;
}

ol, ul {
    padding-left: 35px;
    margin-top: 1.1rem;
    margin-bottom: 1.1rem;
}

ol li {
    padding-left: 10px;	
}

ul li {
    padding-left: 5px;	
}

code, .lang-csharp span, .lang-csharp pre {
    font-family: JB Mono, monospace !important;
}

.lang-csharp {
    padding: 4px 0px 14px 0px;
}


.lang-csharp > div {
    border-left-color: #eee;
    border-left-style: dotted;
    border-left-width: 3px;
    padding-left: 25px;
}

code {
    font-size: 14px;
    border: gainsboro;
    border-width: 1px;
    border-style: solid;
    padding: 2px;
    color: darkslateblue;
}

.lang-csharp span, .lang-csharp pre {
    font-size: 13px;
    line-height: 20px;
}

p a {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #b88b59;
}

p img {
    width: 95%;
}

img < p {
    text-align: center;
}

blockquote p {
    margin: 16px 0;
    padding: 12px 12px 13px;
    border: 1px solid rgba(0,0,0,.08);
    border-radius: 8px;
    background: #fff8c4;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-size: 16px;
    font-weight: 400;
    line-height: 24px;
}

blockquote p code {
    font-family: consolas, monospace;
    font-size: 17px;
    background-color: aliceblue;
    padding: 4px 6px;
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
    padding: 0;
    font-weight: 400;
}

h1 {
    font-size: 38px;
    font-family: PF Regal,PF Regal Text Pro,Georgia,serif;
    font-weight: 400;
    margin: 40px 0 10px 0;
}

h1 b {
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-weight: 700;
    font-size: 37px;
    line-height: 42px;
}

h2 {
    margin-top: 35px;
    margin-bottom: 10px;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-size: 20px;
    font-weight: 700;
    line-height: 24px;
    border-bottom-color: aliceblue;
    border-bottom-style: solid;
    padding-bottom: 5px;
}

h3 {
    margin: 30px 0 10px 0;
    border-bottom-color: azure;
    border-bottom-style: solid;
    border-bottom-width: 2px;
    font-size: 17pt;
    font-weight: 300;
}


// Fonts
@font-face {
    font-family: 'JB Mono';
    src: local('JetBrains Mono'),
    url('../../res/fonts/woff2/JetBrainsMono-Italic.woff2') format('woff2'),
    url('../../res/fonts/woff/JetBrainsMono-Italic.woff') format('woff'),
    url('../../res/fonts/ttf/JetBrainsMono-Italic.ttf') format('truetype');
    font-weight: 400;
    font-style: italic;
}
@font-face {
    font-family: 'JB Mono';
    src: local('JetBrains Mono'),
    url('../../res/fonts/woff2/JetBrainsMono-Regular.woff2') format('woff2'),
    url('../../res/fonts/woff/JetBrainsMono-Regular.woff') format('woff'),
    url('../../res/fonts/ttf/JetBrainsMono-Regular.ttf') format('truetype');
    font-weight: 400;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: local('JetBrains Mono'),
    url('../../res/fonts/woff2/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
    url('../../res/fonts/woff/JetBrainsMono-Medium-Italic.woff') format('woff'),
    url('../../res/fonts/ttf/JetBrainsMono-Medium-Italic.ttf') format('truetype');
    font-weight: 600;
    font-style: italic;
}
@font-face {
    font-family: 'JB Mono';
    src: local('JetBrains Mono'),
    url('../../res/fonts/woff2/JetBrainsMono-Medium.woff2') format('woff2'),
    url('../../res/fonts/woff/JetBrainsMono-Medium.woff') format('woff'),
    url('../../res/fonts/ttf/JetBrainsMono-Medium.ttf') format('truetype');
    font-weight: 600;
    font-style: normal;
}
@font-face {
    font-family: 'PF Regal Text Pro';
    src: local('PF Regal Text Pro RegularA'), local('PF-Regal-Text-Pro-RegularA'),
    url('../../res/fonts/woff2/PFRegalTextPro-RegularA.woff2') format('woff2'),
    url('../../res/fonts/woff/PFRegalTextPro-RegularA.woff') format('woff'),
    url('../../res/fonts/ttf/PFRegalTextPro-RegularA.ttf') format('truetype');
    font-weight: 400;
    font-style: normal;
}
@font-face {
    font-family: 'PF Regal Text Pro';
    src: local('PF Regal Text Pro RegularB'), local('PF-Regal-Text-Pro-RegularB'),
    url('../../res/fonts/woff2/PFRegalTextPro-RegularB.woff2') format('woff2'),
    url('../../res/fonts/woff/PFRegalTextPro-RegularB.woff') format('woff'),
    url('../../res/fonts/ttf/PFRegalTextPro-RegularB.ttf') format('truetype');
    font-weight: 600;
    font-style: normal;
}
@font-face {
    font-family: 'PF Regal Text Pro';
    src: local('PF Regal Text Pro RegularB Italic'), local('PF-Regal-Text-Pro-RegularB-Italic'),
    url('../../res/fonts/woff2/PFRegalTextPro-RegularBItalic.woff2') format('woff2'),
    url('../../res/fonts/woff/PFRegalTextPro-RegularBItalic.woff') format('woff'),
    url('../../res/fonts/ttf/PFRegalTextPro-RegularBItalic.ttf') format('truetype');
    font-weight: 600;
    font-style: italic;
}
  
    </style>

<div style="margin:auto; width:100%;">
<div style="width:1000px;">
    <h1 id="section">Стек потока</h1>
<blockquote>
<p><a href="https://github.com/sidristij/dotnetbook/issues/58">Ссылка на обсуждение</a></p>
</blockquote>
<h2 id="x86">Базовая структура, платформа x86</h2>
<p>Существует область памяти, про которую редко заходит разговор. Однако эта область является, возможно, основной в работе приложения. Самой часто используемой, достаточно ограниченной с моментальным выделением и освобождением памяти. Область эта называется &quot;стек потока&quot;. Причём поскольку указатель на него кодируется по своей сути регистрами процессора, которые входят в контекст потока, то в рамках исполнения любого потока стек потока свой. Зачем он необходим?</p>
<p>Итак, разберём элементарный пример кода:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Method1()
{
    Method2(123);
}

<span style="color:Blue;">void</span> Method2(<span style="color:Blue;">int</span> arg)
{
    <span style="color:Green;">// ...</span>
}
</pre></div>
</div>
<p>В данном коде не происходит ничего примечательного, однако не будем его пропускать, а наоборот: посмотрим на него максимально внимательно. Когда любой <code>Method1</code> вызывает любой <code>Method2</code>, то абсолютно любой такой вызов (и не только в .NET, но и в других платформах) осуществляет следующие операции:</p>
<ol>
<li>Первое, что делает код, скомпилированный JIT'ом: он сохраняет параметры метода в стек (начиная с третьего). При этом первые два передаются через регистры. Тут важно помнить, что первым параметром экземплярных методов передаётся указатель на тот объект, с которым работает метод. Т.е. указатель <code>this</code>. Так что в этих (почти всех) случаях для регистров остаётся всего один параметр, а для всех остальных - стек;</li>
<li>Далее компилятор ставит инструкцию вызова метода <code>call</code>, которая помещает в стек адрес возврата из метода: адрес следующей за <code>call</code> инструкцией. Таким образом любой метод знает, куда ему необходимо вернуться, чтобы вызывающий код смог продолжить работу;</li>
<li>После того как все параметры переданы, а метод вызван, нам надо как-то понять, как стек восстановить в случае выхода из метода, если мы не хотим заботиться о подсчёте занимаемых нами в стеке байтов. Для этого мы сохраняем значение регистра EBP, который всегда хранит указатель на начало текущего кадра стека (т.е. участка, где хранится информация для конкретного вызванного метода). Сохраняя при каждом вызове значение этого регистра, мы тем самым фактически создаём односвязный список стековых кадров. Но прошу заметить, что по факту они идут чётко друг за другом, без каких-либо пробелов. Однако для упрощения освобождения памяти из-под кадра и для отладки приложения (отладчик использует эти указатели, чтобы отобразить Stack Trace) строится односвязный список;</li>
<li>Последнее, что надо сделать при вызове метода, - выделить участок памяти под локальные переменные. Поскольку компилятор заранее знает, сколько её понадобится, то делает он это сразу, сдвигая указатель на вершину стека (SP/ESP/RSP) на необходимое количество байт;</li>
<li>И наконец, на пятом этапе выполняется код метода, полезные операции;</li>
<li>Когда происходит выход из метода, то вершина стека восстанавливается из EBP - места, где хранится начало текущего стекового кадра;</li>
<li>Далее, последним этапом осуществляется выход из метода через инструкцию <code>ret</code>. Она забирает со стека адрес возврата, заботливо оставленный ранее инструкцией <code>call</code> и делает <code>jmp</code> по этому адресу.</li>
</ol>
<p>Те же самые процессы можно посмотреть на изображении:</p>
<p><img src="./imgs/ThreadStack/AnyMethodCall.png" alt="" /></p>
<p>Также замечу, что стек &quot;растёт&quot;, начиная со старших адресов и заканчивая младшими, т.е. в обратную сторону.</p>
<p>Глядя на все это, невольно приходишь к выводу, что если не большинство, то минимум половина всех операций, которыми занимается процессор - это обслуживание структуры программы, а не её полезной нагрузки. Т.е. обслуживание вызовов методов, проверки типов на возможность привести один к другому, компиляцию Generic вариаций, поиск методов в таблицах интерфейсов... Особенно если мы вспомним, что большинство современного кода написано с подходом работы через интерфейсы, разбивку на множество пусть маленьких, но выполняющих каждый - своё - методов… А работа при этом часто идёт с базовыми типами и приведением типов то к интерфейсу, то к наследнику. При всех таких входящих условиях вывод о расточительности инфраструктурного кода вполне может назреть. Единственное, что я могу вам на это все сказать: компиляторы, в том числе и JIT, обладают множеством техник, позволяющим им делать более продуктивный код. Где можно - вместо вызова метода вставляется его тело целиком, а где возможно вместо поиска метода в VSD интерфейса осуществляется его прямой вызов. Что самое грустное, инфраструктурную нагрузку очень сложно замерить: надо чтобы JITter либо какой-либо компилятор вставлял бы какие-то метрики до и после мест работы инфраструктурного кода. Т.е. до вызова метода, а внутри метода - после инициализации кадра стека. До выхода из метода, после выхода из метода. До компиляции, после компиляции. И так далее. Однако, давайте не будем о грустном, а поговорим лучше о том, что мы можем с вами сделать с полученной информацией.</p>
<h2 id="x86-1">Немного про исключения на платформе x86</h2>
<p>Если мы посмотрим внутрь кода методов, то мы заметим ещё одну структуру, работающую со стеком потока. Посудите сами:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Method1()
{
    <span style="color:Blue;">try</span>
    {
        Method2(123);
    } <span style="color:Blue;">catch</span> {
        <span style="color:Green;">// ...</span>
    }
}

<span style="color:Blue;">void</span> Method2(<span style="color:Blue;">int</span> arg)
{
    Method3();
}

<span style="color:Blue;">void</span> Method3()
{
    <span style="color:Blue;">try</span>
    {
        <span style="color:Green;">//...</span>
    } <span style="color:Blue;">catch</span> {
        <span style="color:Green;">//...</span>
    }
}
</pre></div>
</div>
<p>Если исключение возникнет в любом из методов, вызванных из <code>Method3</code>, то управление будет возвращено в блок <code>catch</code> метода <code>Method3</code>. При этом если исключение обработано не будет, то его обработка начнётся в методе <code>Method1</code>. Однако если ничего не случится, то <code>Method3</code> завершит свою работу, управление перейдёт в метод <code>Method2</code>, где также может возникнуть исключение. Однако по естественным причинам обработано оно будет не в <code>Method3</code>, а в <code>Method1</code>. Вопрос такого удобного автоматизма заключается в том, что структуры данных, образующие цепочки обработчиков исключений, также находятся в стековом кадре метода, где они объявлены. Про сами исключения мы поговорим отдельно, а здесь скажу только, что модель исключений в .NET Framework CLR и в Core CLR отличается. CoreCLR вынуждена быть разной на разных платформах, а потому модель исключений там другая и представляется в зависимости от платформы через прослойку PAL (Platform Adaption Layer) различными имплементациями. Большому .NET Framework CLR это не нужно: он живёт в экосистеме платформы Windows, в которой есть уже много лет общеизвестный механизм обработки исключений, который называется SEH (Structured Exception Handling). Этот механизм используется практически всеми языками программирования (при конечной компиляции), потому что обеспечивает сквозную обработку исключений между модулями, написанными на различных языках программирования. Работает это примерно так:</p>
<ol>
<li>При вхождении в блок try на стек кладётся структура, которая первым полем указывает на предыдущий блок обработки исключений (например, вызывающий метод, у которого также есть try-catch), тип блока, код исключения и адрес обработчика;</li>
<li>В TEB потока (Thread Environment Block, по сути - контекст потока) меняется адрес текущей вершины цепочки обработчиков исключений на тот, что мы создали. Таким образом, мы добавили в цепочку наш блок.</li>
<li>Когда try закончился, производится обратная операция: в TEB записывается старая вершина, снимая таким образом наш обработчик из цепочки;</li>
<li>Если возникает исключение, то из TEB забирается вершина и по очереди по цепочке вызываются обработчики, которые проверяют, подходит ли исключение конкретно им. Если да, выполняется блок обработки (например, catch).</li>
<li>В TEB восстанавливается тот адрес структуры SEH, который находится в стеке ДО метода, обработавшего исключение.</li>
</ol>
<p>Как видите, совсем не сложно. Однако вся эта информация также находится в стеке.</p>
<h2 id="x64-amd64-in-progress">Базовые сведения про платформы x64, AMD64 [In Progress]</h2>
<p>TODO</p>
<h2 id="x64-amd64-in-progress-1">Исключения на платформах x64, AMD64 [In Progress]</h2>
<p>TODO</p>
<h2 id="section-1">Совсем немного про несовершенство стека потока</h2>
<p>Давайте немного подумаем о вопросе безопасности и возможных проблемах, которые чисто теоретически могут возникнуть. Для этого давайте ещё раз глянем на структуру стека потока, которая по своей сути - обычный массив. Диапазон памяти, в котором строятся фреймы, организован так, что он растёт с конца в начало. Т.е. более поздние фреймы располагаются по более ранним адресам. Так же, как уже было сказано, фреймы связаны односвязным списком. Это сделано потому, что размер фрейма не является фиксированным и должен быть &quot;считан&quot; любым отладчиком. Процессор при этом не разграничивает фреймы между собой: любой метод по своему желанию может считать всю область памяти целиком. А если учесть при этом, что мы находимся в виртуальной памяти, которая поделена на участки, являющиеся реально выделенной памятью, то можно при помощи специальной функции WinAPI по любому адресу со стека получить диапазон выделенной памяти, в которой этот адрес находится. Ну а разобрать односвязный список - дело техники:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// переменная находится в стеке</span>
    <span style="color:Blue;">int</span> x;

    <span style="color:Green;">// Забрать информацию об участке памяти, выделенной под стек</span>
    MEMORY_BASIC_INFORMATION *stackData = <span style="color:Blue;">new</span> MEMORY_BASIC_INFORMATION();
    VirtualQuery((<span style="color:Blue;">void</span> *)&amp;x, stackData, <span style="color:Blue;">sizeof</span>(MEMORY_BASIC_INFORMATION));
</pre></div>
</div>
<p>Это даёт нам возможность получить и модифицировать все данные, которые находятся в качестве локальных переменных у методов, которые нас вызвали. Если приложение никак не настраивает песочницу, в рамках которой вызываются сторонние библиотеки, расширяющие функционал приложения, то сторонняя библиотека сможет утащить данные, даже если тот API, который вы ей отдаёте, этого не предполагает. Методика эта может показаться вам надуманной, однако в мире C/C++, где нет такой прекрасной вещи как AppDomain с настроенными правами атака по стеку - это самое типичное, что только можно встретить из взлома приложений. Мало того, можно через рефлексию посмотреть на тип, который нам необходим, повторить его структуру у себя, и, пройдя по ссылке со стека на объект, заменить адрес VMT на наш, перенаправив таким образом всю работу с конкретным экземпляром к нам. SEH, кстати говоря, также вовсю используется для взлома приложений. Через него вы также можете, меняя адрес обработчика исключения, заставлять ОС выполнить вредоносный код. Но вывод из всего этого очень простой: всегда настраивайте песочницу, когда хотите работать с библиотеками, расширяющими функционал вашего приложения. Я, конечно же, имею ввиду всяческие плагины, аддоны и прочие расширения.</p>
<h2 id="section-2">Большой пример: клонирование потока на платформе х86</h2>
<p>Чтобы запомнить все, что мы прочитали до мельчайших подробностей, надо зайти к вопросу освещения какой-либо темы с нескольких сторон. Казалось бы, какой пример можно построить для стека потока? Вызвать метод из другого? Магия... Конечно же, нет: это мы делаем ежедневно по много раз. Вместо этого мы склонируем поток исполнения. Т.е. сделаем так, чтобы после вызова определённого метода у нас вместо одного потока оказалось бы два: наш и новый, но продолжающий выполнять код с точки вызова метода клонирования так, как будто он сам туда дошёл. А выглядеть это будет так:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> MakeFork()
{
    <span style="color:Green;">// Для уверенности что все склонировалось мы делаем локальные переменные:</span>
    <span style="color:Green;">// В новом потоке их значения обязаны быть такими же как и в родительском</span>
    <span style="color:Blue;">var</span> sameLocalVariable = 123;
    <span style="color:Blue;">var</span> sync = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();

    <span style="color:Green;">// Замеряем время</span>
    <span style="color:Blue;">var</span> stopwatch = Stopwatch.StartNew();

    <span style="color:Green;">// Клонируем поток</span>
    <span style="color:Blue;">var</span> forked = Fork.CloneThread();

    <span style="color:Green;">// С этой точки код исполняется двумя потоками.</span>
    <span style="color:Green;">// forked = true для дочернего потока, false для родительского</span>
    <span style="color:Blue;">lock</span>(sync)
    {
        Console.WriteLine(<span style="color:#A31515;">&quot;in {0} thread: {1}, local value: {2}, time to enter = {3} ms&quot;</span>,
            forked ? <span style="color:#A31515;">&quot;forked&quot;</span> : <span style="color:#A31515;">&quot;parent&quot;</span>,
            Thread.CurrentThread.ManagedThreadId,
            sameLocalVariable,
            stopwatch.ElapsedMilliseconds);
    }

    <span style="color:Green;">// При выходе из метода родительский вернёт управления в метод,</span>
    <span style="color:Green;">// который вызвал MakeFork(), т.е. продолжит работу как ни в чем ни бывало,</span>
    <span style="color:Green;">// а дочерний завершит исполнение.</span>
}

<span style="color:Green;">// Примерный вывод:</span>
<span style="color:Green;">// in forked thread: 2, local value: 123, time to enter = 2 ms</span>
<span style="color:Green;">// in parent thread: 1, local value: 123, time to enter = 2 ms</span>
</pre></div>
</div>
<p>Согласитесь, концепт интересный. Конечно же, тут можно много спорить про целесообразность таких действий, но задача этого примера - поставить жирную точку в понимании работы этой структуры данных. Как же сделать клонирование? Для ответа на данный вопрос надо ответить на другой вопрос: что вообще определяет поток? А поток определяют следующие структуры и области данных:</p>
<ol>
<li>Набор регистров процессора. Все регистры определяют состояние потока исполнения инструкций: от адреса текущей инструкции исполнения до адресов стека потока и данных, которыми он оперирует;</li>
<li><a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">Thread Environment Block</a> или TIB/TEB, который хранит системную информацию по потоку, включая адреса обработчиков исключений;</li>
<li>Стек потока, адрес которого определяется регистрами SS:ESP;</li>
<li>Платформенный контекст потока, который содержит локальные для потока данные (ссылка идёт из TIB)</li>
</ol>
<p>Ну и наверняка что-то ещё, о чем мы можем не знать. Да и знать нам всего для примера нет никакой надобности: в промышленное использование данный код не пойдёт, а скорее будет служить нам отличным примером, который поможет разобраться в теме. А потому он не будет учитывать всего, а только самое основное. А для того чтобы он заработал в базовом виде, нам понадобится скопировать в новый поток набор регистров (исправив SS:ESP, т.к. стек будет новым), а также подредактировать сам стек, чтобы он содержал ровно то что нам надо.</p>
<p>Итак. Если стек потока определяет, по сути, какие методы были вызваны и какими данными они оперируют, то получается что по идее, меняя эти структуры, можно поменять как локальные переменные методов, так и вырезать из стека вызов какого-то метода, поменять метод на другой или же добавить в любое место цепочки свой. Хорошо, с этим определились. Теперь давайте посмотрим на некий псевдокод:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> RootMethod()
{
    MakeFork();
}
</pre></div>
</div>
<p>Когда вызовется MakeFork(), что мы ожидаем с точки зрения стек трейсов? Что в родительском потоке все останется без изменений, а дочерний будет взят из пула потоков (для скорости), в нем будет сымитирован вызов метода <code>MakeFork</code> вместе с его локальными переменными, а код продолжит выполнение не с начала метода, а с точки, следующей после вызова <code>CloneThread</code>. Т.е. стек трейс в наших фантазиях будет выглядеть примерно так:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Parent Thread</span>
RootMethod -&gt; MakeFork

<span style="color:Green;">// Child Thread</span>
ThreadPool -&gt; MakeFork
</pre></div>
</div>
<p>Что у нас есть изначально? Есть наш поток. Также есть возможность создать новый поток либо запланировать задачу в пул потоков, выполнив там свой код. Также мы понимаем, что информация по вложенным вызовам хранится в стеке вызовов и что при желании мы можем ею манипулировать (например, используя C++/CLI). Причём, если следовать соглашениям и вписать в верхушку стека адрес возврата для инструкции ret, значение регистра EBP и выделить место под локальные (если необходимо), то можно имитировать вызов метода. Ручную запись в стек потока возможно сделать из C#, однако нам понадобятся регистры и их очень аккуратное использование, а потому без ухода в C++ нам не обойтись. Тут к нам на помощь впервые в жизни (лично у меня) приходит CLI/C++, который позволяет писать смешанный код: часть инструкций - на .NET, часть - на C++, а иногда даже уходить на уровень ассемблера. Именно то, что нам надо.</p>
<p>Итак, как будет выглядеть стек потока, когда наш код вызовет MakeFork, который вызовет CloneThread, который уйдёт в unmanaged мир CLI/C++ и вызовет метод клонирование (саму реализацию) - там? Давайте посмотрим на схему (ещё раз напомню, что стек растёт от старших адресов к младшим. Справа налево):</p>
<p><img src="./imgs/ThreadStack/step1.png" alt="" /></p>
<p>Ну а для того чтобы не тащить всю простыню со схемы на схему, упростим, отбросив то, что нам не нужно:</p>
<p><img src="./imgs/ThreadStack/step2.png" alt="" /></p>
<p>Когда мы создадим поток либо возьмём готовый из пула потоков, в нашей схеме появляется ещё один стек, пока ещё ничем не проинициализированный:</p>
<p><img src="./imgs/ThreadStack/step3.png" alt="" /></p>
<p>Теперь наша задача - сымитировать запуск метода <code>Fork.CloneThread()</code> в новом потоке. Для этого мы должны в конец его стека потока дописать серию кадров: как будто из делегата, переданного ThreadPool'у был вызван <code>Fork.CloneThread()</code>, из которого через враппер C++ кода managed обёрткой был вызван CLI/C++ метод. Для этого мы просто скопируем необходимый участок стека в массив (замечу, что со склонированного участка на старый &quot;смотрят&quot; копии регистров EBP, обеспечивающих построение цепочки кадров):</p>
<p><img src="./imgs/ThreadStack/step4.png" alt="" /></p>
<p>Далее чтобы обеспечить целостность стека после операции копирования склонированного на предыдущем шаге участка, мы заранее рассчитываем, по каким адресам будут находиться поля <code>EBP</code> на новом месте, и сразу же исправляем их, прямо на копии:</p>
<p><img src="./imgs/ThreadStack/step5.png" alt="" /></p>
<p>Последним шагом, очень аккуратно, задействуя минимальное количество регистров, копируем наш массив в конец стека дочернего потока, после чего сдвигаем регистры ESP и EBP на новые места. С точки зрения стека мы сымитировали вызов всех этих методов:</p>
<p><img src="./imgs/ThreadStack/step6.png" alt="" /></p>
<p>Но пока не с точки зрения кода. С точки зрения кода нам надо попасть в те методы, которые только что создали. Самое простое - просто сымитировать выход из метода: восстановить <code>ESP</code> до <code>EBP</code>, в <code>EBP</code> положить то, на что он указывает и вызвать инструкцию <code>ret</code>, инициировав выход из якобы вызванного C++ метода клонирования потока, что приведёт к возврату в реальный wrapper CLI/C++ вызова, который вернёт управление в <code>MakeFork()</code>, но в дочернем потоке. Техника сработала.</p>
<p>Теперь давайте взглянем на код. Первое что мы сделаем - это возможность для CLI/C++ кода создать .NET поток. Для этого мы его должны создать в .NET:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">extern</span> <span style="color:#A31515;">&quot;C&quot;</span> __declspec(dllexport)
<span style="color:Blue;">void</span> __stdcall MakeManagedThread(AdvancedThreading_Unmanaged *helper, StackInfo *stackCopy)
{
    AdvancedThreading::Fork::MakeThread(helper, stackCopy);
}
</pre></div>
</div>
<p>На типы параметров пока не обращайте внимания. Они нужны для передачи информации о том, какой участок стека необходимо у себя рисовать из родительского потока в дочерний. Метод создания потока оборачивает в делегат вызов unmanaged метода, передаёт данные и ставит делегат в очередь на обработку пулом потоков.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">void</span> MakeThread(AdvancedThreading_Unmanaged *helper, StackInfo *stackCopy)
{
    ForkData^ data = gcnew ForkData();
    data-&gt;helper = helper;
    data-&gt;info = stackCopy;

    ThreadPool::QueueUserWorkItem(gcnew WaitCallback(&amp;InForkedThread), data);
}

[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">void</span> InForkedThread(Object^ state)
{
    ForkData^ data = (ForkData^)state;
    data-&gt;helper-&gt;InForkedThread(data-&gt;info);
}
</pre></div>
</div>
<p>И, наконец, сам метод клонирования (вернее, его .NET часть):</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">bool</span> CloneThread()
{
    ManualResetEvent^ resetEvent = gcnew ManualResetEvent(<span style="color:Blue;">false</span>);
    AdvancedThreading_Unmanaged *helper = <span style="color:Blue;">new</span> AdvancedThreading_Unmanaged();
    <span style="color:Blue;">int</span> somevalue;

    <span style="color:Green;">// *</span>
    helper-&gt;stacktop = (<span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span> *)&amp;somevalue;
    <span style="color:Blue;">int</span> forked = helper-&gt;ForkImpl();
    <span style="color:Blue;">if</span> (!forked)
    {
        resetEvent-&gt;WaitOne();
    }
    <span style="color:Blue;">else</span>
    {
        resetEvent-&gt;Set();
    }
    <span style="color:Blue;">return</span> forked;
}
</pre></div>
</div>
<p>Чтобы понимать, где в цепочке кадров стека находится данный метод, мы сохраняем себе адрес стековой переменной (*). Использовать этот адрес мы будем в методе клонирования, речь о котором пойдёт чуть ниже. Также, чтобы вы понимали, о чем идёт речь, приведу код структуры, необходимой для хранения информации о копии стека:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> StackInfo
{
<span style="color:Blue;">public</span>:
    <span style="color:Green;">// Копия значений регистров</span>
    <span style="color:Blue;">int</span> EAX, EBX, ECX, EDX;
    <span style="color:Blue;">int</span> EDI, ESI;
    <span style="color:Blue;">int</span> ESP;
    <span style="color:Blue;">int</span> EBP;
    <span style="color:Blue;">int</span> EIP;
    <span style="color:Blue;">short</span> CS;

    <span style="color:Green;">// Адрес копии стека</span>
    <span style="color:Blue;">void</span> *frame;

    <span style="color:Green;">// Размер копии</span>
    <span style="color:Blue;">int</span> size;

    <span style="color:Green;">// Диапазоны адресов оригинального стека нужны,</span>
    <span style="color:Green;">// чтобы поправить адреса на стеке если они есть на новые</span>
    <span style="color:Blue;">int</span> origStackStart, origStackSize;
};
</pre></div>
</div>
<p>Работа же самого алгоритма разделена на две части: в родительском потоке мы подготавливаем данные для того, чтобы в дочернем потоке отрисовать нужные кадры стека. Вторым же этапом восстанавливаются данные в дочернем потоке, накладываясь на свой собственный стек потока исполнения, имитируя, таким образом, вызовы методов, которые в реальности вызваны не были.</p>
<h3 id="section-3">Метод подготовки к копированию</h3>
<p>Описание кода я буду делать блоками. Т.е. единый код будет разбит на части, и каждая из частей будет отдельно прокомментирована. Итак, приступим. Когда внешний код вызывает <code>Fork.CloneThread()</code>, то через внутреннюю обёртку над неуправляемым кодом и через ряд дополнительных методов, если код работает под отладкой (так называемые debugger assistants). Именно поэтому мы в .NET части запомнили адрес переменной в стеке: для C++ метода этот адрес является своеобразной меткой: теперь мы точно знаем, какой участок стека мы можем спокойно копировать.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span> AdvancedThreading_Unmanaged::ForkImpl()
{
    StackInfo copy;
    StackInfo* info;
</pre></div>
</div>
<p>Первым делом, до того как произойдёт хоть какая-то операция, чтобы не получить запорченные регистры, мы их копируем локально. Также дополнительно необходимо сохранить адрес кода, куда будет сделан <code>goto</code>, когда в дочернем потоке стек будет сымитирован, и необходимо будет произвести процеруду выхода из <code>CloneThread</code> из дочернего потока. В качестве &quot;точки выхода&quot; мы выбираем <code>JmpPointOnMethodsChainCallEmulation</code> и не просто так: после операции сохранения этого адреса &quot;на будущее&quot; мы дополнительно закладываем в стек число 0.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// Save ALL registers</span>
    _asm
    {
        mov copy.EAX, EAX
        mov copy.EBX, EBX
        mov copy.ECX, ECX
        mov copy.EDX, EBX
        mov copy.EDI, EDI
        mov copy.ESI, ESI
        mov copy.EBP, EBP
        mov copy.ESP, ESP

        <span style="color:Green;">// Save CS:EIP for far jmp</span>
        mov copy.CS, CS
        mov copy.EIP, offset JmpPointOnMethodsChainCallEmulation

        <span style="color:Green;">// Save mark for this method, from what place it was called</span>
        push 0
    }
</pre></div>
</div>
<p>После чего, после <code>JmpPointOnMethodsChainCallEmulation</code> мы достаём это число из стека и проверяем: там лежит <code>0</code>? Если да, мы находимся в том же самом потоке: а значит у нас ещё много дел, и мы переходим на <code>NonClonned</code>. Если же там не <code>0</code>, а по факту <code>1</code>, это значит, что дочерний поток закончил &quot;дорисовку&quot; стека потока до необходимого состояния, положил на стек число <code>1</code> и сделал goto в эту точку (замечу, что goto он делает из другого метода). А это значит, что настало время для выхода из <code>CloneThread</code> в дочернем потоке, вызов которого был сымитирован.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
JmpPointOnMethodsChainCallEmulation:

    _asm
    {
        pop EAX
        cmp EAX, 0
        je NonClonned

        pop EBP
        mov EAX, 1
        ret
    }
NonClonned:
</pre></div>
</div>
<p>Хорошо, мы убедились, что мы все ещё мы, а значит надо подготовить данные для дочернего потока. Чтобы более не спускаться на уровень ассемблера, работать мы будем со структурой ранее сохранённых регистров. Достанем из неё значение регистра EBP: он по сути является полем &quot;Next&quot; в односвязном списке кардов стека. Перейдя по адресу, который там содержится, мы очутимся в кадре метода, который нас вызвал. Если и там возьмём первое поле и перейдём по тому адресу, то окажемся в ещё более раннем кадре. Так мы сможем дойти до managed части <code>CloneThread</code>: ведь мы сохранили адрес переменной в её стековом кадре, а значит, прекрасно знаем, где остановиться. Этой задачей и занимается цикл, приведённый ниже.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">int</span> *curptr = (<span style="color:Blue;">int</span> *)copy.EBP;
    <span style="color:Blue;">int</span> frames = 0;

    <span style="color:Green;">//</span>
    <span style="color:Green;">//  Calculate frames count between current call and Fork.CloneTherad() call</span>
    <span style="color:Green;">//</span>
    <span style="color:Blue;">while</span> ((<span style="color:Blue;">int</span>)curptr &lt; stacktop)
    {
        curptr = (<span style="color:Blue;">int</span>*)*curptr;
        frames++;
    }
</pre></div>
</div>
<p>Получив адрес начала кадра managed метода <code>CloneThread</code>, мы теперь знаем, сколько надо копировать для имитации вызова <code>CloneThread</code> из <code>MakeFork</code>. Однако поскольку нам <code>MakeFork</code> также нужен (наша задача выйти именно в него), то мы делаем дополнительно ещё один переход по односвязному списку: <code>*(int *)curptr</code>. После чего создаём массив под сохранение стека и сохраняем его простым копированием.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">//</span>
    <span style="color:Green;">//  We need to copy stack part from our method to user code method including its locals in stack</span>
    <span style="color:Green;">//</span>
    <span style="color:Blue;">int</span> localsStart = copy.EBP;                             <span style="color:Green;">// our EBP points to EBP value for parent method + saved ESI, EDI</span>
    <span style="color:Blue;">int</span> localsEnd = *(<span style="color:Blue;">int</span> *)curptr;                         <span style="color:Green;">// points to end of user&#39;s method&#39;s locals (additional leave)</span>

    <span style="color:Blue;">byte</span> *arr = <span style="color:Blue;">new</span> <span style="color:Blue;">byte</span>[localsEnd - localsStart];
    memcpy(arr, (<span style="color:Blue;">void</span>*)localsStart, localsEnd - localsStart);
</pre></div>
</div>
<p>Ещё одна задача, которую надо будет решить, - это исправление адресов переменных, которые попали на стек и при этом указывающих на стек. Для решения этой проблемы мы получаем диапазон адресов, которые нам выделила операционная система под стек потока. Сохраняем полученную информацию и запукаем вторую часть процесса клонирования, запланировав делегат в пул потоков:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// Get information about stack pages</span>
    MEMORY_BASIC_INFORMATION *stackData = <span style="color:Blue;">new</span> MEMORY_BASIC_INFORMATION();
    VirtualQuery((<span style="color:Blue;">void</span> *)copy.EBP, stackData, <span style="color:Blue;">sizeof</span>(MEMORY_BASIC_INFORMATION));

    <span style="color:Green;">// fill StackInfo structure</span>
    info = <span style="color:Blue;">new</span> StackInfo(copy);
    info-&gt;origStackStart = (<span style="color:Blue;">int</span>)stackData-&gt;BaseAddress;
    info-&gt;origStackSize = (<span style="color:Blue;">int</span>)stackData-&gt;RegionSize;
    info-&gt;frame = arr;
    info-&gt;size = (localsEnd - localsStart);

    <span style="color:Green;">// call managed ThreadPool.QueueUserWorkitem to make fork</span>
    MakeManagedThread(<span style="color:Blue;">this</span>, info);

    <span style="color:Blue;">return</span> 0;
}
</pre></div>
</div>
<h3 id="section-4">Метод восстановления из копии</h3>
<p>Этот метод вызывается как результат работы предыдущего: нам переданы копия участка стека родительского потока, а также полный набор его регистров. Наша задача в нашем потоке, взятом из пула потоков, дорисовать все вызовы, скопированные из родительского потока таким образом, как будто мы сами их осуществили. Завершив работу, MakeFork дочернего потока попадёт обратно в этот метод, который, завершив работу, освободит поток и вернёт его в пул потоков.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> AdvancedThreading_Unmanaged::InForkedThread(StackInfo * stackCopy)
{
    StackInfo copy;
</pre></div>
</div>
<p>Первым делом мы сохраняем значения рабочих регистров, чтобы, когда <code>MakeFork</code> завершит свою работу, мы смогли их безболезненно восставновить. Чтобы в дальнейшем минимально влиять на регистры, мы выгружаем переданные нам параметры к себе на стек. Доступ к ним будет идти только через <code>SS:ESP</code>, что для нас будет предсказуемым.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">short</span> CS_EIP[3];

    <span style="color:Green;">// Save original registers to restore</span>
    __asm pushad

    <span style="color:Green;">// safe copy w-out changing registers</span>
    <span style="color:Blue;">for</span>(<span style="color:Blue;">int</span> i = 0; i &lt; <span style="color:Blue;">sizeof</span>(StackInfo); i++)
        ((<span style="color:Blue;">byte</span> *)&amp;copy)[i] = ((<span style="color:Blue;">byte</span> *)stackCopy)[i];

    <span style="color:Green;">// Setup FWORD for far jmp</span>
    *(<span style="color:Blue;">int</span>*)CS_EIP = copy.EIP;
    CS_EIP[2] = copy.CS;
</pre></div>
</div>
<p>Наша следующая задача - это исправить в копии стека значения <code>EBP</code>, которые образуют односвязный список кадров на их будущие новые положения. Для этого мы рассчитываем дельту между адресом нашего стека потока и родительского стека потока, дельту между копией диапазона стека родительского потока и самим родительским потоком.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// calculate ranges</span>
    <span style="color:Blue;">int</span> beg = (<span style="color:Blue;">int</span>)copy.frame;
    <span style="color:Blue;">int</span> size = copy.size;
    <span style="color:Blue;">int</span> baseFrom = (<span style="color:Blue;">int</span>) copy.origStackStart;
    <span style="color:Blue;">int</span> baseTo = baseFrom + (<span style="color:Blue;">int</span>)copy.origStackSize;
    <span style="color:Blue;">int</span> ESPr;

    __asm mov ESPr, ESP

    <span style="color:Green;">// target = EBP[ - locals - EBP - ret - whole stack frames copy]</span>
    <span style="color:Blue;">int</span> targetToCopy = ESPr - 8 - size;

    <span style="color:Green;">// offset between parent stack and current stack;</span>
    <span style="color:Blue;">int</span> delta_to_target = (<span style="color:Blue;">int</span>)targetToCopy - (<span style="color:Blue;">int</span>)copy.EBP;

    <span style="color:Green;">// offset between parent stack start and its copy;</span>
    <span style="color:Blue;">int</span> delta_to_copy = (<span style="color:Blue;">int</span>)copy.frame - (<span style="color:Blue;">int</span>)copy.EBP;
</pre></div>
</div>
<p>Используя эти данные, мы в цикле идём по копии стека и исправляем адреса на их будущие новые положения.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// In stack copy we have many saved EPBs, which where actually one-way linked list.</span>
    <span style="color:Green;">// we need to fix copy to make these pointers correct for our thread&#39;s stack.</span>
    <span style="color:Blue;">int</span> ebp_cur = beg;
    <span style="color:Blue;">while</span>(<span style="color:Blue;">true</span>)
    {
        <span style="color:Blue;">int</span> val = *(<span style="color:Blue;">int</span>*)ebp_cur;

        <span style="color:Blue;">if</span>(baseFrom &lt;= val &amp;&amp; val &lt; baseTo)
        {
            <span style="color:Blue;">int</span> localOffset = val + delta_to_copy;
            *(<span style="color:Blue;">int</span> *)ebp_cur += delta_to_target;
            ebp_cur = localOffset;
        }
        <span style="color:Blue;">else</span>
            <span style="color:Blue;">break</span>;
    }
</pre></div>
</div>
<p>Когда правка односвязного списка завершена, мы должны исправить значения регистров в их копии, чтобы, если там присутствуют ссылки на стек, они были бы исправлены. Тут на самом деле алгоритм совсем не точен. Ведь если там по некоторой случайности окажется не удачное число из диапазона адресов стека, то оно будет исправлено по ошибке. Но наша задача не для продукта концепт написать, а просто понять работу стека потока. Потому для этих целей нам данная методика подойдёт.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    CHECKREF(EAX);
    CHECKREF(EBX);
    CHECKREF(ECX);
    CHECKREF(EDX);

    CHECKREF(ESI);
    CHECKREF(EDI);
</pre></div>
</div>
<p>Теперь, основная и самая ответственная часть. Когда мы скопируем в конец нашего стека копию диапазона родительского, все будет хорошо до момента, когда <code>MakeFork</code> в дочернем потоке захочет выйти (сделать <code>return</code>). Нам надо указать ему, куда он должен выйти. Для этого мы также имитируем вызов самого 'MakeFork' из этого метода. Мы закладываем в стек адрес метки <code>RestorePointAfterClonnedExited</code>, как будто инструкция процессора <code>call</code> заложила в стек адрес возврата, а также положили текущий <code>EBP</code>, сымитировав построение односвязного списка цепочек кадров методов. После чего закладываем в стек обычной операцией <code>push</code> копию родительского стека тем самым отрисовав все методы, которые были вызваны в родительском стеке из метода <code>MakeFork</code>, включая его самого. Стек готов!</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// prepare for __asm nret</span>
    __asm push offset RestorePointAfterClonnedExited
    __asm push EBP

    <span style="color:Blue;">for</span>(<span style="color:Blue;">int</span> i = (size &gt;&gt; 2) - 1; i &gt;= 0; i--)
    {
        <span style="color:Blue;">int</span> val = ((<span style="color:Blue;">int</span> *)beg)[i];
        __asm push val;
    };
</pre></div>
</div>
<p>Далее поскольку мы также должны восстановить и регистры, восстанавливаем и их самих.</p>
<pre><code>    // restore registers, push 1 for Fork() and jmp
    _asm {
        push copy.EAX
        push copy.EBX
        push copy.ECX
        push copy.EDX
        push copy.ESI
        push copy.EDI
        pop EDI
        pop ESI
        pop EDX
        pop ECX
        pop EBX
        pop EAX
</code></pre>
<p>А вот теперь самое время вспомнить тот странный код с закладыванием <code>0</code> в стек и проверки на <code>0</code>. В этом потоке мы закладываем <code>1</code> и делаем дальний jmp в код метода <code>ForkImpl</code>. Ведь по стеку мы находимся именно там, а реально все ещё тут. Когда мы туда попадём, то <code>ForkImpl</code> распознает смену потока и осуществит выход в метод <code>MakeFork</code>, который, завершив работу, попадёт в точку <code>RestorePointAfterClonnedExited</code>, т.к. немного ранее мы сымтировали вызов <code>MakeFork</code> из этой точки. Восстановив регистры до состояния &quot;только что вызваны из TheadPool&quot;, мы завершаем работу, отдавая поток в пул потоков.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
        push 1
        jmp fword ptr CS_EIP
    }

RestorePointAfterClonnedExited:

    <span style="color:Green;">// Restore original registers</span>
    __asm popad
    <span style="color:Blue;">return</span>;
 }
</pre></div>
</div>
<p>Проверим? Это - скриншот до вызова клонирования потока:</p>
<p><img src="./imgs/ThreadStack/ForkBeforeEnter.png" alt="" /></p>
<p>И после:</p>
<p><img src="./imgs/ThreadStack/ForkAfterEnter.png" alt="" /></p>
<p>Как мы видим, теперь вместо одного потока внутри ForkImpl мы видим два. И оба - вышли из этого метода.</p>
<h1 id="section-5">Пара слов об уровне пониже</h1>
<p>Если мы заглянем краем глаза на ещё более низкий уровень, то узнаем или же вспомним, что память на самом деле является виртуальной и что она поделена на страницы объёмом 8 или 4 Кб. Каждая такая страница может физически существовать или же нет. А если она существует, то может быть отображена на файл или же реальную оперативную память. Именно этот механизм виртуализации позволяет приложениям иметь раздельную друг от друга память и обеспечивает уровни безопасности между приложением и операционной системой. При чем же здесь стек потока? Как и любая другая оперативная память приложения стек потока является её частью и также состоит из страниц объёмом 4 или 8 Кб. По краям от выделенного для стека пространства находятся две страницы, доступ к которым приводит к системному исключению, нотифицирующему операционную систему о том, что приложение пытается обратиться в невыделенный участок памяти. Внутри этого региона реально выделенными участками являются только те страницы, к которым обратилось приложение: т.е. если приложение резервирует под поток 2Мб памяти, это не значит, что они будут выделены сразу же. Отнюдь, они будут выделены по требованию: если стек потока вырастет до 1 Мб, это будет означать, что приложение получило именно 1 Мб оперативной памяти под стек.</p>
<p>Когда приложение резервирует память под локальные переменные, то происходят две вещи: наращивается значение регистра ESP и зануляется память под сами переменные. Поэтому, когда вы напишете рекурсивный метод, который уходит в бесконечную рекурсию, вы получите StackOverflowException: заняв всю выделенную под стек память (весь доступный регион), вы напоритесь на специальную страницу, Guard Page, доступ к которой вызовет нотификацию операционной системы, которая инициирует StackOverflow уровня ОС, которое уйдёт в .NET, будет перехвачено и выбросется исключение StackOverflowException для .NET приложения.</p>
<h1 id="stackalloc">Выделение памяти на стеке: stackalloc</h1>
<p>В C# существует достаточно интересное и очень редко используемое ключевое слово <code>stackalloc</code>. Оно настолько редко встречается в коде (тут я даже со словом &quot;немного&quot; преуменьшил. Скорее, &quot;никогда&quot;), что найти подходящий пример его использования достаточно трудно, а уж придумать тем более трудно: ведь если что-то редко используется, то и опыт работы с ним слишком мал. А все почему? Потому что для тех, кто наконец решается выяснить, что делает эта команда, <code>stackalloc</code> становится более пугающим чем полезным: тёмная сторона <code>stackalloc</code> - unsafe код. Тот результат, что он возвращает не является managed указателем: значение - обычный указатель на участок не защищённой памяти. Причём если по этому адресу сделать запись уже после того, как метод завершил работу, вы начнёте писать в локальные переменные некоторого метода или же вообще перетрёте адрес возврата из метода, после чего приложение закончит работу с ошибкой. Однако наша задача - проникнуть в самые уголки и разобраться, что в них скрыто. И понять, в частности, что если нам дали этот инструмент, то не просто же так, чтобы мы смогли найти секретные грабли и наступить на них со всего маху. Наоборот: нам дали этот инструмент чтобы мы смогли им воспользоваться и делать поистине быстрый софт. Я, надеюсь, вдохновил вас? Тогда начнём.</p>
<p>Чтобы найти правильные примеры использования этого ключевого слова надо проследовать прежде всего к его авторам: компании Microsoft и посмотреть как его используют они. Сделать это можно поискав полнотекстовым поиском по репозиторию <a href="https://github.com/dotnet/coreclr">coreclr</a>. Помимо различных тестов самого ключевого слова мы найдём не более 25 использований этого ключевого слова по коду библиотеки. Я надеюсь, что в предыдущем абзаце я достаточно сильно вас мотивировал, чтобы вы не остановили чтение, увидев эту маленькую цифру, и не закрыли мой труд. Скажу честно: команда CLR куда более дальновидная и профессиональная чем команда .NET Framework. И если она что-то сделала, то это нам сильно в чем-то должно помочь. А если это не использовано в .NET Framework... Ну, тут можно предположить, что там не все инженеры в курсе, что есть такой мощный инструмент оптимизации. Иначе бы объёмы его использования были бы гораздо больше.</p>
<p><strong>Класс Interop.ReadDir</strong>
<a href="https://github.com/dotnet/coreclr/blob/b29f6328510207970763580d6f4db864e4b198af/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs#L71-L83">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a></p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">unsafe</span>
{
    <span style="color:Green;">// s_readBufferSize is zero when the native implementation does not support reading into a buffer.</span>
    <span style="color:Blue;">byte</span>* buffer = <span style="color:Blue;">stackalloc</span> <span style="color:Blue;">byte</span>[s_readBufferSize];
    InternalDirectoryEntry temp;
    <span style="color:Blue;">int</span> ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, <span style="color:Blue;">out</span> temp);
    <span style="color:Green;">// We copy data into DirectoryEntry to ensure there are no dangling references.</span>
    outputEntry = ret == 0 ?
                <span style="color:Blue;">new</span> DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } :
                <span style="color:Blue;">default</span>(DirectoryEntry);

    <span style="color:Blue;">return</span> ret;
}
</pre></div>
</div>
<p>Для чего здесь используется <code>stackalloc</code>? Как мы видим, после выделения памяти код уходит в unsafe метод для заполнения созданного буфера данными. Т.е. unsafe метод, которому необходим участок для записи, выделяется место прямо на стеке: динамически. Это отличная оптимизация, если учесть, что альтернативы: запросить участок памяти у Windows или fixed (pinned) массив .NET, который помимо нагрузки на кучу нагружает GC тем, что массив прибивается гвоздями, чтобы GC его не пододвинул во время доступа к его данным. Выделяя память на стеке, мы не рискуем ничем: выделение происходит почти моментально, и мы можем совершенно спокойно заполнить его данными и выйти из метода. А вместе с выходом из метода исчезнет и stack frame метода. В общем, экономия времени значительнейшая.</p>
<p>Давайте рассмотрим ещё один пример:</p>
<p><strong>Класс Number.Formatting::FormatDecimal</strong>
<a href="https://github.com/dotnet/coreclr/blob/efebb38f3c18425c57f94ff910a50e038d13c848/src/mscorlib/shared/System/Number.Formatting.cs#L287-L311">/src/mscorlib/shared/System/Number.Formatting.cs</a></p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">static</span> <span style="color:Blue;">string</span> FormatDecimal(<span style="color:Blue;">decimal</span> value, ReadOnlySpan&lt;<span style="color:Blue;">char</span>&gt; format, NumberFormatInfo info)
{
    <span style="color:Blue;">char</span> fmt = ParseFormatSpecifier(format, <span style="color:Blue;">out</span> <span style="color:Blue;">int</span> digits);

    NumberBuffer number = <span style="color:Blue;">default</span>;
    DecimalToNumber(value, <span style="color:Blue;">ref</span> number);

    ValueStringBuilder sb;
    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Blue;">char</span>* stackPtr = <span style="color:Blue;">stackalloc</span> <span style="color:Blue;">char</span>[CharStackBufferSize];
        sb = <span style="color:Blue;">new</span> ValueStringBuilder(<span style="color:Blue;">new</span> Span&lt;<span style="color:Blue;">char</span>&gt;(stackPtr, CharStackBufferSize));
    }

    <span style="color:Blue;">if</span> (fmt != 0)
    {
        NumberToString(<span style="color:Blue;">ref</span> sb, <span style="color:Blue;">ref</span> number, fmt, digits, info, isDecimal:<span style="color:Blue;">true</span>);
    }
    <span style="color:Blue;">else</span>
    {
        NumberToStringFormat(<span style="color:Blue;">ref</span> sb, <span style="color:Blue;">ref</span> number, format, info);
    }

    <span style="color:Blue;">return</span> sb.ToString();
}
</pre></div>
</div>
<p>Это - пример форматирования чисел, опирающийся на ещё более интересный пример класса <a href="https://github.com/dotnet/coreclr/blob/efebb38f3c18425c57f94ff910a50e038d13c848/src/mscorlib/shared/System/Text/ValueStringBuilder.cs">ValueStringBuilder</a>, работающий на основе <code>Span&lt;T&gt;</code>. Суть данного участка кода в том, что для того чтобы собрать текстовое представление форматированного числа максимально быстро, код не использует выделения памяти под буфер накопления символов. Этот прекрасный код выделяет память прямо в стековом кадре метода, обеспечивая тем самым отсутствие работы сборщика мусора по экземплярам StringBuilder, если бы метод работал на его основе. Плюс уменьшается время работы самого метода: выделение памяти в куче тоже время занимает. А использование типа <code>Span&lt;T&gt;</code> вместо голых указателей вносит чувство безопасности в работу кода, основанного на stackalloc.</p>
<p>Также, перед тем как перейти к выводам, стоит упомянуть, как делать нельзя. Другими словами, какой код может работать хорошо, но в один прекрасный момент выстрелит в самый не подходящий момент. Опять же, рассмотрим пример:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> GenerateNoise(<span style="color:Blue;">int</span> noiseLength)
{
    <span style="color:Blue;">var</span> buf = <span style="color:Blue;">new</span> Span(<span style="color:Blue;">stackalloc</span> <span style="color:Blue;">int</span>[noiseLength]);
    <span style="color:Green;">// generate noise</span>
}
</pre></div>
</div>
<p>Код мал да удал: нельзя вот так брать и передавать размер для выделения памяти на стеке извне. Если вам так нужен заданный снаружи размер, примите сам буфер:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> GenerateNoise(Span&lt;<span style="color:Blue;">int</span>&gt; noiseBuf)
{
    <span style="color:Green;">// generate noise</span>
}
</pre></div>
</div>
<p>Этот код гораздо информативнее, т.к. заставляет пользователя задуматься и быть аккуратным при выборе чисел. Первый вариант при неудачно сложившихся обстоятельствах может выбросить <code>StackOverflowException</code> при достаточно неглубоком положении метода в стеке потока: достаточно передать большое число в качестве параметра. Второй вариант, когда размер принимать всё-таки можно - это когда этот метод вызывается в конкретных случаях и при этом вызывающий код &quot;знает&quot; алгоритм работы этого метода. Без знания о внутреннем устройстве метода нет конкретного понимания возможного диапазона для noiseLength и как следствие - возможны ошибки</p>
<p>Вторая проблема, которую я вижу: если нам случайным образом не удалось попасть в размер того буфера, который мы сами себе выделили на стеке, а терять работоспособность мы не хотим, то, конечно, можно пойти несколькими путями: либо довыделить памяти, опять же на стеке, либо выделить её в куче. Причём, скорее всего второй вариант в большинстве случаев окажется более предпочтительным (так и поступили в случае <code>ValueStringBuffer</code>), т.к. более безопасен с точки зрения получения <code>StackOverflowException</code>.</p>
<h2 id="stackalloc-1">Выводы к stackalloc</h2>
<p>Итак, для чего же лучше всего использовать <code>stackalloc</code>?</p>
<ul>
<li><p>Для работы с неуправляемым кодом, когда необходимо заполнить неуправляемым методом некоторый буфер данных или же принять от неуправляемого метода некий буфер данных, который будет использоваться в рамках жизни тела метода;</p>
</li>
<li><p>Для методов, которым нужен массив, но опять же на время работы самого метода. Пример с форматированием очень хороший: этот метод может вызываться слишком часто чтобы он выделял временные массивы в куче;</p>
</li>
</ul>
<p>Использование данного аллокатора может сильно повысить производительность ваших приложений.</p>
<h1 id="section-6">Выводы к разделу</h1>
<p>Конечно же, в общем виде нам нет надобности редактировать стек в продуктовом коде: только если захочется занять своё свободное время интересной задачкой. Однако понимание его структуры даёт нам видимость простоты задачи получения данных из него и его редактирования. Т.е. если вы разработаете API для расширения функционала вашего приложения и если это API не предоставляет доступа к каким-либо данным это не значит что эти данные невозможно получить. Потому всегда проверяйте ваше приложение на устойчивость к взломам.</p>

</div>
</div>
</body>
</html>