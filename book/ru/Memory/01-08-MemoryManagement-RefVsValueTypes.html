<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>.NET Platform Architecture</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <link rel="stylesheet" href="../../../out/res/bootstrap.css">
    <style>
        body {
    padding: 60px 60px 60px 100px;
    font-family: PF Regal,Georgia,serif;
    font-size: 16pt;
    font-weight: 300;
}

strong {
    font-weight: 500;
}

p, li {
    margin: 0 0 20px;
    line-height: 32px;
    font-family: inherit;
}

ol, ul {
    padding-left: 35px;
    margin-top: 1.1rem;
    margin-bottom: 1.1rem;
}

ol li {
    padding-left: 10px;	
    font-family: inherit;
}

ul li {
    padding-left: 12px;	
    font-family: inherit;
}

table {
    margin: 30px 0;
    width: 100%;
}

thead {                         
    background-color: aliceblue;
}

table th {
    font-weight: 400;
}

table td, table th {
    padding: 7px;
    border-top: solid darkgrey 1px;
    border-bottom: solid darkgrey 1px;
    border-right: dotted darkgray 1px;
    border-left: dotted darkgray 1px;
    font-size: smaller;
}

code, *[class^='lang-'] span, *[class^='lang-'] pre {
    font-family: JB Mono, monospace !important;
}

*[class^='lang-'] {
    padding: 4px 0px 14px 0px;
}


*[class^='lang-'] > div, pre > code {
    border-left-color: #eee;
    border-left-style: dotted;
    border-left-width: 3px;
    padding-left: 25px;
    display: block;
    background-color: aliceblue !important;
    padding-top: 20px;
    padding-bottom: 20px;
}

*[class^='lang-'] > div pre, pre > code pre {
    margin-bottom: 0;
}

p code:not(.highlight), li code:not(.highlight) {
    font-size: 16px;
    border: gainsboro;
    border-width: 1px;
    border-style: solid;
    padding: 4px;
    color: darkslateblue;
}

code.highlight {
    font-family: inherit !important;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
}

p code.highlight, li code.highlight {
    padding: 4px;
    background-color: #ffffa1;
}

*[class^='lang-'] span, *[class^='lang-'] pre, pre > code {
    font-size: 13px;
    line-height: 20px;
}

p a, li a {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #b88b59;
}

blockquote h5 {
    background-color: aquamarine;
    margin: 16px 0 16px -20px;
    padding: 15px 30px 15px;
}

p img {
    width: 95%;
}

p:has( > img) {
    text-align: center;
}

blockquote > p.big-quote {
    margin: 40px 0 60px 0;
    font-family: Charter;
    font-size: 55px;
    line-height: 60px;
    width: 150%;
    padding: 0;
}

blockquote:not( p.big-quote) {
    background-color: lavenderblush;
    padding-left: 20px;
    border-left: 1px solid rgba(0,0,0,.08);
}

blockquote p {
    margin: 16px 0;
    padding: 12px 12px 13px;
    font-family: inherit;
}

blockquote p code {
    font-family: consolas, monospace;
    font-size: 17px;
    background-color: aliceblue;
    padding: 4px 6px;
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
    padding: 0;
    font-weight: 400;
    font-family: inherit;
}

h1 {
    font-size: 40px;
    font-family: PF Regal,Georgia,serif;
    font-weight: 300;
    margin: 40px 0 20px 0;
    border-bottom-style: ridge;
    padding-bottom: 10px;
}

h1 b {
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-weight: 700;
    font-size: 37px;
    line-height: 42px;
}

h2 {
    margin-top: 35px;
    margin-bottom: 10px;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-size: 20px;
    font-weight: 700;
    line-height: 24px;
    border-bottom-color: grey;
    border-bottom-style: solid;
    padding-bottom: 5px;
}

h3 {
    margin: 30px 0 15px 0;
    font-size: 17pt;
    font-weight: 400;
}

h4 {
    margin: 20px 0 10px 0;
    font-size: 16pt;
    font-weight: 400;
}

/* Fonts */

/*@font-face {*/
/*    font-family: 'PF Regal';*/
/*    src: url('../../../out/res/fonts/PFRegalTextPro-RegularA.eot');*/
/*    src: local('../../../out/res/fonts/PFRegalTextPro-RegularA'),*/
/*        url('../../../out/res/fonts/PFRegalTextPro-RegularA.woff2') format('woff2'),*/
/*        url('../../../out/res/fonts/PFRegalTextPro-RegularA.woff') format('woff'),*/
/*        url('../../../out/res/fonts/PFRegalTextPro-RegularA.ttf') format('truetype');*/
/*    font-weight: 300;*/
/*    font-style: normal;*/
/*}*/

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-Bold.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-Bold'),
        url('../../../out/res/fonts/PFRegalTextPro-Bold.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-Bold.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-Medium.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-Medium'),
        url('../../../out/res/fonts/PFRegalTextPro-Medium.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-Medium.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-BlackItalic.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-BlackItalic'),
        url('../../../out/res/fonts/PFRegalTextPro-BlackItalic.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-BlackItalic.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-BlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-Black.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-Black'),
        url('../../../out/res/fonts/PFRegalTextPro-Black.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-Black.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-Black.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal UBlack';
    src: url('../../../out/res/fonts/PFRegalTextPro-UBlack.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-UBlack'),
        url('../../../out/res/fonts/PFRegalTextPro-UBlack.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-UBlack.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-UBlack.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-MediumItalic.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-MediumItalic'),
        url('../../../out/res/fonts/PFRegalTextPro-MediumItalic.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-MediumItalic.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-MediumItalic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-UBlackItalic.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-UBlackItalic'),
        url('../../../out/res/fonts/PFRegalTextPro-UBlackItalic.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-UBlackItalic.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-UBlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-RegularAItalic.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-RegularAItalic'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularAItalic.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularAItalic.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularAItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-BoldItalic.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-BoldItalic'),
        url('../../../out/res/fonts/PFRegalTextPro-BoldItalic.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-BoldItalic.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-BoldItalic.ttf') format('truetype');
    font-weight: bold;
    font-style: italic;
}

@font-face {
    font-family: 'Charter';
    src: url('../../../out/res/fonts/charter-regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}

/*  Regular B */
@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-RegularBItalic.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-RegularBItalic'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularBItalic.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularBItalic.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularBItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../../out/res/fonts/PFRegalTextPro-RegularB.eot');
    src: local('../../../out/res/fonts/PFRegalTextPro-RegularB'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularB.woff2') format('woff2'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularB.woff') format('woff'),
        url('../../../out/res/fonts/PFRegalTextPro-RegularB.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}                
    </style>

<div class="row">
<div class="offset-1 col-6">
<p style="
    font-size: 70pt;
    margin: 85px 0 85px 0;
    text-align: center;
">a:
   </p>
    <h1 id="section">Ссылочные и значимые типы данных</h1>
<p>Теперь, когда мы укрепили свои знания основ в управлении памятью в .NET, давайте поговорим про Reference Types и Value Types. И если говорить про разницу между ними и про полезность каждого из типов, то первое, о чем я бы упомянул &mdash; так это о своих мыслях об их названии. На мой скромный взгляд, если бы в русскоязычном сегменте их назвали ссылочные и значимые типы вместо проговаривания Value Types и Reference Types, то с пониманием разницы между ними все бы встало на свои места.</p>
<blockquote>
<p>Очень часто при вопросе что такое ссылочные и значимые типы, люди отвечают, что ссылочные живут в куче, а значимые &mdash; в стеке. И это в корне неправильно. Это настолько маленькая часть правды, что правдой не может считаться в принципе</p>
</blockquote>
<p>Также, чтобы понимать разницу между ними, давайте и будем изучать их с точки зрения разницы:</p>
<ul>
<li><code class="highlight">*Значимый тип*:  значением является **вся структура целиком**. Для *ссылочного типа* значением является **ссылка** на объект</code>;</li>
<li><code class="highlight">По структуре в памяти</code>: значимые типы содержат только те данные, которые вы указали. Ссылочные также содержат два системных поля. Первое необходимо для хранения <code>SyncBlockIndex</code>, второе &mdash; для хранения информации о типе: в том числе и о Virtual Methods Table (VMT)</li>
<li>Однако, ссылочные типы можно наследовать, переопределяя методы. Значимые типы лишены такой возможности;</li>
<li>Но, чтобы выделить ссылочный тип, надо аллоцировать место в куче. Значимый тип <em>может</em> работать на стеке, не уходя в кучу, а может стать частью ссылочного типа. Это свойство может значительно повысить производительность для некоторых алгоритмов;</li>
</ul>
<p>Однако, есть и общие черты.</p>
<blockquote>
<p class="big-quote">  Оба подкласса наследуют тип object, а значит &mdash; могут выступать как его представители: на полных правах</p>
</blockquote>
<p>Рассмотрим каждую особенность в отдельности.</p>
<h2 id="section-1">Копирование</h2>
<p>Самую главную и основополагающую разницу между типами можно описать примерно так:</p>
<ul>
<li>Любая переменная, поле класса/структуры или же параметр метода, которые принимают ссылочный тип, на самом деле хранят в себе <strong>ссылку</strong> на значение;</li>
<li>Тогда как любая переменная, поле класса/структуры или же параметр метода, которые принимают значимый тип, на самом деле хранят в себе именно значение. Т.е. всю структуру целиком;</li>
</ul>
<p>Что это значит для нас? Это в частности значит, что любое присваивание или прокидывание через параметр метода вызовет копирование значения. А поменяв копию, оригинал изменён не будет. При этом если вы меняете поля ссылочного типа, изменения &laquo;получают&raquo; все, кто имеют ссылку на экземпляр типа. Давайте рассмотрим это на примере:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

 DateTime dt = DateTime.Now;   <span style="color:Green;">// Здесь сначала при вызове метода будет выделено место под переменную DateTime,</span>
                               <span style="color:Green;">// но заполнено оно будет нулями. Далее копируется все значение свойства Now в переменную dt</span>
 DateTime dt2 = dt;            <span style="color:Green;">// Здесь значение копируется ещё раз</span>

 <span style="color:Blue;">object</span> obj = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();    <span style="color:Green;">// Тут мы создаём объект, выделяя память в Small Object Heap, и размещаем указатель на объект в переменной obj</span>
 <span style="color:Blue;">object</span> obj2 = obj;            <span style="color:Green;">// Тут мы копируем ссылку на этот объект. Т.е. объект &mdash; один, а ссылок &mdash; две</span>

</pre></div>
</div>
<p>Это свойство рождает ряд двусмысленных на первый взгляд конструкций кода. Одна из них &mdash; изменение значений в коллекциях:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Объявим структуру</span>
<span style="color:Blue;">struct</span> ValueHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Data;
}

<span style="color:Green;">// Создадим массив таких структур и проинициализируем поле Data = 5</span>
<span style="color:Blue;">var</span> array = <span style="color:Blue;">new</span> [] { <span style="color:Blue;">new</span> ValueHolder { Data = 5 } };

<span style="color:Green;">// Заберём по индексу структуру и в поле Data выставим 4</span>
array[0].Data = 4;

<span style="color:Green;">// Проверим значение</span>
Console.WriteLine(array[0].Data);
</pre></div>
</div>
<p>В данном коде есть маленькая хитрость. Код выглядит так, будто мы сначала достаём экземпляр структуры, а затем у полученной копии выставляем поле Data в новое значение. А это значит, что при проверке мы снова должны получить <code>5</code>. Однако все совсем не так. Все дело в том, что в MSIL есть отдельная инструкция для выставления значения полей структур, находящихся в массивах. Она была введена для повышения производительности. И этот код отработает именно так, как и было задумано его автором: программа выведет в консоль число <code>4</code>.</p>
<p>Однако стоит изменить пример так:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Объявим структуру</span>
<span style="color:Blue;">struct</span> ValueHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Data;
}

<span style="color:Green;">// Создадим список таких структур и проинициализируем поле Data = 5</span>
<span style="color:Blue;">var</span> list = <span style="color:Blue;">new</span> List&lt;ValueHolder&gt; { <span style="color:Blue;">new</span> ValueHolder { Data = 5 } };

<span style="color:Green;">// Заберём по индексу структуру и в поле Data выставим 4</span>
list[0].Data = 4;

<span style="color:Green;">// Проверим значение</span>
Console.WriteLine(list[0].Data);
</pre></div>
</div>
<p>Так у нас ничего даже и не скомпилируется. А все потому, что когда вы пишете <code>list[0].Data = 4</code>, то сначала вы получаете именно копию структуры. Вы ведь на самом деле вызываете метод экземпляра типа List<T>, который скрывается за доступом по индексу. И который в свою очередь забирает копию структуры из внутреннего массива (List<T> хранит данные в массивах), которая возвращается из метода доступа по индексу &mdash; вам. После чего вы пытаетесь модифицировать копию, которая далее нигде не используется. Это &mdash; не то чтобы ошибка, но абсолютно бессмысленный код. А компилятор, зная, что люди путаются с Value Types, запрещает такое поведение. Поэтому пример должен быть переписан таким образом:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Объявим структуру</span>
<span style="color:Blue;">struct</span> ValueHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Data;
}

<span style="color:Green;">// Создадим список таких структур и проинициализируем поле Data = 5</span>
<span style="color:Blue;">var</span> list = <span style="color:Blue;">new</span> List&lt;ValueHolder&gt; { <span style="color:Blue;">new</span> ValueHolder { Data = 5 } };

<span style="color:Green;">// Заберём по индексу структуру и в поле Data выставим 4, после чего сохраним обратно</span>
<span style="color:Blue;">var</span> copy = list[0];
copy.Data = 4;
list[0] = copy;

<span style="color:Green;">// Проверим значение</span>
Console.WriteLine(list[0].Data);
</pre></div>
</div>
<p>Несмотря на кажущееся многословие, он корректен. Когда программа отработает, в консоль выведется число <code>4</code>.</p>
<p>Вторым примером я хочу показать вам, что вообще понимается под &laquo;значением структуры является вся структура целиком&quot;</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Вариант 1</span>
<span style="color:Blue;">struct</span> PersonInfo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
}

<span style="color:Blue;">int</span> x = 5;
PersonInfo person;
<span style="color:Blue;">int</span> y = 6;

<span style="color:Green;">// Вариант 2</span>
<span style="color:Blue;">int</span> x = 5;
<span style="color:Blue;">int</span> Height;
<span style="color:Blue;">int</span> Width;
<span style="color:Blue;">int</span> HairColor;
<span style="color:Blue;">int</span> y = 6;
</pre></div>
</div>
<p>Фактически, по расположению данных в памяти оба примера идентичны. Потому как значением структуры является вся структура в целом. Куда она попала, там под себя память и определила.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Вариант 1</span>
<span style="color:Blue;">struct</span> PersonInfo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
}

<span style="color:Blue;">class</span> Employee
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">public</span> PersonInfo person;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> y;
}

<span style="color:Green;">// Вариант 2</span>
<span style="color:Blue;">class</span> Employee
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> y;
}
</pre></div>
</div>
<p>Эти примеры также идентичны с точки зрения положения элементов в памяти, т.к. структура просто встаёт туда, где её определили: среди полей класса. Я не утверждаю, что это абсолютно идентично: ведь в структуре вы можете оперировать над её полями при помощи методов структуры.</p>
<p>Если говорить про ссылочные типы, то, понятное дело, для них все обстоит иначе. Сам экземпляр находится в недосягаемом Small Object Heap (SOH) или же в Large Object Heap (LOH), а в поле класса запишется лишь значение указателя на экземпляр: 32-х или 64-разрядное число.</p>
<p>Последний пример, надеюсь, вас не запутает. Но мне хотелось поставить точку в этом вопросе.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Вариант 1</span>
<span style="color:Blue;">struct</span> PersonInfo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
}

<span style="color:Blue;">void</span> Method(<span style="color:Blue;">int</span> x, PersonInfo person, <span style="color:Blue;">int</span> y);

<span style="color:Green;">// Вариант 2</span>
<span style="color:Blue;">void</span> Method(<span style="color:Blue;">int</span> x, <span style="color:Blue;">int</span> HairColor, <span style="color:Blue;">int</span> Width, <span style="color:Blue;">int</span> Height, <span style="color:Blue;">int</span> y);
</pre></div>
</div>
<p>Вы меня поняли совершенно корректно: с точки зрения работы с памятью оба варианта будут работать одинаково (но не архитектурной! это вам не замена переменного числа аргументов!). Почему изменился порядок? Потому что параметры метода объявляются друг за другом и в этом порядке складываются в стек потока. Однако стек растёт от старших адресов к младшим, а это значит, что порядок складывания по очереди будет отличаться от порядка складывания структуры целиком.</p>
<h2 id="section-2">Переопределяемые методы и наследование</h2>
<p>Вторая глобальная разница между ними &mdash; это отсутствие таблицы виртуальных методов в структурах. Это означает что:</p>
<ol>
<li>В структурах нельзя описать <code>virtual</code> методы, а также &mdash; переопределять их;</li>
<li>Структуры в принципе нельзя наследовать друг от друга. Единственный способ сделать эмуляцию наследования &mdash; расположить структуру базового типа первым полем. Тогда по смещениям они будут совпадать, поля &laquo;унаследованной&raquo; структуры будут располагаться после полей &laquo;базовой&raquo;, и логически вы сделаете наследование;</li>
<li>Структуры в отличии от классов можно передавать в unmanaged код. Я имею ввиду именно значение. Информация о методах, естественно, будет утеряна. Ведь структура &mdash; это просто отрезок памяти, заполненный данными без информации о типе. А это значит, что её можно без изменений отдавать в unmanaged методы, написанные, например, на C++.</li>
</ol>
<p>Отсутствие таблицы виртуальных методов хоть и отнимает у структур часть &laquo;магии&raquo;, которую вносит понятие наследования, но и наделяет рядом преимуществ. Первое и самое главное уже было оговорено: мы можем легко и просто отдать во внешний мир (за пределы .NET Framework) экземпляр такой структуры. Это ведь просто участок памяти! Либо мы можем принять из unmanaged кода некий участок памяти и сделать приведение типа к нашей структуре, чтобы сделать более удобный доступ к её полям. С классами такое поведение не пройдёт: у классов существует два поля, которые никому не доступны: это SyncBlockIndex и адрес таблицы виртуальных методов. Если эти два поля уйдут в unmanaged код, это станет очень опасным. Ведь с любой таблицей виртуальных методов можно умеючи достучаться до любого типа и поменять его, осуществив атаку на приложение.</p>
<p>Давайте докажем, что это просто участок памяти без какой-либо дополнительной логики:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">unsafe</span> <span style="color:Blue;">void</span> Main()
{
    <span style="color:Blue;">int</span> secret = 666;
    HeightHolder hh;
    hh.Height = 5;

    WidthHolder wh;
    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Green;">// Если бы у структур была информация о типе, это приведение не смогло бы работать:</span>
        <span style="color:Green;">// CLR перед приведением типа проверила бы иерархию и, не найдя в ней WidthHolder,</span>
        <span style="color:Green;">// выбросила бы InvalidCastException. Но поскольку структура &mdash; просто участок памяти,</span>
        <span style="color:Green;">// в unsafe мире никто не мешает вам интерпретировать его какой угодно структурой</span>
        wh = *(WidthHolder*)&amp;hh;
    }
    Console.WriteLine(<span style="color:#A31515;">&quot;Width: &laquo;</span> + wh.Width);
    Console.WriteLine(<span style="color:#A31515;">&quot;Secret: &laquo;</span> + wh.Secret);
}

<span style="color:Blue;">struct</span> WidthHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Secret;
}

<span style="color:Blue;">struct</span> HeightHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
}
</pre></div>
</div>
<p>В данном примере мы осуществляем недопустимую с точки зрения строгой типизации операцию: мы приводим один тип к несовместимому другому, который содержит одно лишнее поле. В методе <code>Main</code> мы вводим дополнительную переменную, значение которой по идее секретно и не должно быть считано. Однако это не так. Пример уверенно выводит на экран значение переменной метода Main(), которая не находится ни в одной из структур. Тут на вашем лице должна расплыться улыбка, а в голове промелькнуть фраза &laquo;ну ни черта себе дыра в безопасности!!!&quot;... Но на самом деле все не так очевидно. Обезопасить свой код от вызываемого unmanaged практически невозможно. Все дело в первую очередь &mdash; в структуре стека потока, о котором мы поговорим чуть позже, и по которому можно легко уйти в вызываемый код, и похимичить с локальными переменными. Защита от такого рода атак строится другими путями. Например, на рандомизации размера кадра стека или на стирании информации о регистре EBP &mdash; для усложнения восстановления стекового кадра. Но не будем слишком углубляться: это тема отдельного разговора. Единственное, о чем стоит упомянуть в рамках этого примера, это почему же при том, что переменная <code>secret</code> находится <strong>перед</strong> определением переменной <code>hh</code>, а в структуре <code>WidthHolder</code> &mdash; <strong>после</strong> (т.е. по сути визуально &mdash; в разных местах), её значение прекрасно считалось. А все потому, что стек растёт не слева направо, а наоборот &mdash; справа налево. Т.е. переменные, объявленные первыми, будут находиться по более старшим адресам, а те, кто объявлены позднее &mdash; по более ранним.</p>
<h2 id="section-3">Поведение при вызове экземплярных методов</h2>
<p>Оба типа данных обладают ещё одной интересной особенностью, которая не лежит на поверхности, и которая может пролить ещё немного света в строение обоих типов. И эта особенность связана с вызовом экземплярных методов.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Green;">// Пример с ссылочным типом</span>
<span style="color:Blue;">class</span> FooClass 
{
    <span style="color:Blue;">private</span> <span style="color:Blue;">int</span> x;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">int</span> val)
    {
        x = val;
    }
}

<span style="color:Green;">// Пример с значимым типом</span>
<span style="color:Blue;">struct</span> FooStruct
{
    <span style="color:Blue;">private</span> <span style="color:Blue;">int</span> x;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">int</span> val)
    {
        x = val;
    }
}

FooClass klass = <span style="color:Blue;">new</span> FooClass();
FooStruct strukt = <span style="color:Blue;">new</span> FooStruct();

klass.ChangeTo(10);
strukt.ChangeTo(10);
</pre></div>
</div>
<p>Если рассуждать логически, то можно легко и просто прийти к выводу, что тело у метода компилируется одно. Т.е. нет такого, что у каждого экземпляра типа компилируется свой набор методов, который при этом совершенно идентичен набору методов других экземпляров. Однако вызванный метод прекрасно знает, для какого экземпляра он вызван. Это достигается тем, что первым параметром передаётся ссылка на экземпляр типа. Можно наш пример легко переписать, и это будет совершенно идентично тому, что было написано выше (я намеренно не привожу пример с виртуальными методами. У них все по-другому):</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Green;">// Пример с ссылочным типом</span>
<span style="color:Blue;">class</span> FooClass 
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
}

<span style="color:Green;">// Пример с значимым типом</span>
<span style="color:Blue;">struct</span> FooStruct
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
}

<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(FooClass klass, <span style="color:Blue;">int</span> val)
{
    klass.x = val;
}

<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">ref</span> FooStruct strukt, <span style="color:Blue;">int</span> val)
{
    strukt.x = val;
}

FooClass klass = <span style="color:Blue;">new</span> FooClass();
FooStruct strukt = <span style="color:Blue;">new</span> FooStruct();

ChangeTo(klass, 10);
ChangeTo(<span style="color:Blue;">ref</span> strukt, 10);
</pre></div>
</div>
<p>Стоит пояснить, почему я использовал ключевое слово <code>ref</code>. Если бы я его не использовал, то получилась бы ситуация, в которой я получил параметром метода <strong>копию</strong> структуры вместо оригинала, поменял её, а оригинал бы остался неизменным. Мне бы пришлось возвращать изменённую копию из метода вызывающей стороне (ещё одно копирование), а вызывающая сторона сохранила бы это значение обратно в переменной (ещё одно копирование). Вместо этого в экземплярный метод отдаётся указатель на структуру, по которому она и меняется. Сразу оригинал. Заметьте, что передача по указателю никак не влияет на производительность, т.к. любые операции на уровне процессора итак происходят по указателям. Т.е. ref &mdash; это из мира C#, не более того.</p>
<h2 id="section-4">Возможность указать положение элементов</h2>
<p>Ещё одной возможностью обоих классов типов является возможность точно указать, по какому смещению относительно начала структуры в памяти располагается то или иное поле. Это введено по нескольким причинам:</p>
<ul>
<li>для работы с внешними API, которые располагаются в unmanaged world, чтобы не &laquo;отбивать&raquo; до нужного поля неиспользуемыми полями</li>
<li>чтобы, например, приказать компилятору расположить некоторое поле точно в самом начале типа (<code>[FieldOffset(0)]</code>). Тогда это ускорит работу с ним. А если это поле очень часто используется, то на этом можно неплохо сэкономить. Отмечу только одну важную деталь. Указанное справедливо только для значимых типов. Ведь в ссылочных по нулевому смещению располагается адрес таблицы виртуальных методов, который занимает 1 процессорное слово. Т.е. даже если вы обращаетесь к самому первому полю класса, обращение все равно будет идти по более сложной адресации (адрес + смещение). Кстати это сделано не просто так: самым часто используемым полем класса является именно адрес таблицы виртуальных методов, т.к. именно через неё виртуальные методы и вызываются;</li>
<li>вы можете установить несколько полей по одному адресу. Тогда одно и то же значение может быть интерпретировано как различные типы данных. В C++ такой тип данных называется <code>union</code>;</li>
<li>также вы можете ничего не объявлять: компилятор будет размещать поля так, как ему покажется оптимальным. Т.е. конечный порядок полей может оказаться другим;</li>
</ul>
<p><strong>Общие положения</strong></p>
<ul>
<li><strong>Auto</strong>: Среда выполнения автоматически выбирает расположение и упаковку для всех полей класса или структуры. Структуры, определённые с помощью члена этого перечисления, не могут быть предоставлены за пределами управляемого кода. Попытка это сделать приводит к возникновению исключения;</li>
<li><strong>Explicit</strong>: Программист явным образом контролирует точное положение каждого поля объекта. Каждое поле должно использовать FieldOffsetAttribute для указания его точного расположения;</li>
<li><strong>Sequential</strong>: Члены объекта располагаются последовательно в порядке, указанном при проектировании типа. Также они располагаются в соответствии с указанным StructLayoutAttribute.Pack значением шага упаковки.</li>
</ul>
<p><strong>Использование FieldOffset для пропуска неиспользуемых областей структуры</strong></p>
<p>Тут конечно же может возникнуть вопрос, почему вообще могут возникнуть поля, которые не используются вообще. Структуры, идущие из unmanaged мира, могут содержать резервные поля, которые могут быть использованы в будущих версиях библиотеки. Если в мире C/C++ принято отбивать такие пропуски путём добавления полей <code>reserved1, reserved2, ..</code>, то в .NET мы имеем прекрасную возможность просто задать смещение к началу поля при помощи атрибута <code>FieldOffsetAttribute</code> и <code>[StructLayout(LayoutKind.Explicit)]</code>:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[StructLayout(LayoutKind.Explicit)]
<span style="color:Blue;">public</span> <span style="color:Blue;">struct</span> SYSTEM_INFO
{
    [FieldOffset(0)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> OemId;
    <span style="color:Green;">// 92 байта &mdash; резерв</span>
    [FieldOffset(100)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> PageSize;
    [FieldOffset(108)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> ActiveProcessorMask;
    [FieldOffset(116)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> NumberOfProcessors;
    [FieldOffset(124)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> ProcessorType;
}
</pre></div>
</div>
<p>Прошу заметить, что пропуск &mdash; это тоже занятое, но не используемое пространство. Размер структуры будет равен <code>132</code> байта, а не <code>40</code>, как может показаться изначально.</p>
<p><strong>Union</strong></p>
<p>При помощи <code>FieldOffsetAttribute</code> вы можете эмулировать такой тип из мира C/C++ как <code>union</code>. <code>union</code> – это специальный тип, который позволяет обращаться к одним и тем же данным как к разнотипным сущностям. Давайте посмотрим на примере его эмуляцию:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Если прочитать RGBA.Value, мы прочитаем Int32 значение, которое будет аккумуляцией всех остальных полей.</span>
<span style="color:Green;">// Однако если мы попробуем прочитать RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, то мы прочитаем отдельные компоненты Int32 числа</span>
[StructLayout(LayoutKind.Explicit)]
<span style="color:Blue;">public</span> <span style="color:Blue;">struct</span> RGBA
{
    [FieldOffset(0)] <span style="color:Blue;">public</span> <span style="color:Blue;">uint</span> Value;
    [FieldOffset(0)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> R;
    [FieldOffset(1)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> G;
    [FieldOffset(2)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> B;
    [FieldOffset(3)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> Alpha;
}
</pre></div>
</div>
<p>Здесь вы могли бы задуматься и сказать, что такое поведение возможно только для значимых типов, однако это не так. Как бы странно это ни звучало, но такое поведение можно воспроизвести и для ссылочных типов, перекрыв по одному адресу два ссылочных типа или же ссылочный со значимым:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">class</span> Program
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">static</span> <span style="color:Blue;">void</span> Main()
    {
        Union x = <span style="color:Blue;">new</span> Union();
        x.Reference.Value = <span style="color:#A31515;">&quot;Hello!&quot;</span>;
        Console.WriteLine(x.Value.Value);
    }

    [StructLayout(LayoutKind.Explicit)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">class</span> Union
    {
        <span style="color:Blue;">public</span> Union()
        {
            Value = <span style="color:Blue;">new</span> Holder&lt;IntPtr&gt;();
            Reference = <span style="color:Blue;">new</span> Holder&lt;<span style="color:Blue;">object</span>&gt;();
        }

        [FieldOffset(0)]
        <span style="color:Blue;">public</span> Holder&lt;IntPtr&gt; Value;
        
        [FieldOffset(0)]
        <span style="color:Blue;">public</span> Holder&lt;<span style="color:Blue;">object</span>&gt; Reference;
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">class</span> Holder&lt;T&gt;
    {
        <span style="color:Blue;">public</span> T Value;
    }
}
</pre></div>
</div>
<p>Заметьте, что я намеренно перекрыл через Generic тип: при обычном перекрытии в момент загрузки данного типа в домен приложения будет сгенерировано исключение <code>TypeLoadException</code>. На самом деле это только внешне выглядит как брешь в безопасности приложения (особенно со стороны &laquo;плагинов&raquo; к приложению), однако если мы попробуем запустить этот код из-под защищённого домена, то мы получим все тот же самый <code>TypeLoadException</code>.</p>
<h2 id="section-5">Разница в аллокации</h2>
<p>Ещё одним важным свойством, кардинально различающимся для обоих типов, является выделение памяти под объект или структуру. Все дело в том, что для того чтобы выделить память под объект, CLR обязана для начала ответить себе на ряд вопросов. Первый, &mdash; какого размера объект? Меньше он или больше 85К байт? Если меньше, то является ли количество оставшегося места в Small Objects Heap достаточным, чтобы разместить объект? Если нет, запускается Garbage Collection, который для своей работы, по сути, должен сначала обойти граф объектов, а потом сжать их, переместив на освободившееся место. Если и после этой операции нет места в SOH (например, ничего не было освобождено), то инициируется процесс выделения дополнительных страниц виртуальной памяти, чтобы нарастить размер Small Objects Heap. И только после того как все срастётся, выделяется место под объект, а выделенный участок памяти очищается от мусора (обнуляется), размечается SyncBlockIndex и VirtualMethodsTable, после чего ссылка на объект возвращается пользователю.</p>
<p>Если же выделяемый объект имеет размеры, превышающие 85K, то мы имеем дело с Large Objects Heap. Это, например, случай огромных строк и массивов. В этом случае мы должны найти максимально подходящий кусок памяти из списка освобождённых и, если таковых нет, выделить новый участок. Эти процедуры по умолчанию не быстрые, но мы предполагаем, что с объектами такого размера мы будем работать особенно осторожно и они вне контекста данной беседы</p>
<p>Т.е. для RefTypes мы имеем несколько случаев:</p>
<ul>
<li>Размер RefType &lt; 85K, место в SOH есть: выделение памяти идёт достаточно быстро;</li>
<li>Размер RefType &lt; 85K, место в SOH заканчивается: выделение памяти идёт очень медленно;</li>
<li>Размер RefType &gt; 85K, выделение памяти идёт относительно медленно. А с учётом того, что данные операции редки и не могут ввиду своих размеров конкурировать с ValTypes, нас это сейчас не сильно волнует.</li>
</ul>
<p>Каков же алгоритм выделения памяти под Value Types? А нет его. Выделение памяти под Value Types не стоит абсолютно ничего. Единственное, что происходит при его &laquo;выделении&raquo; &mdash; это обнуление полей. Давайте разберёмся, почему так происходит:</p>
<ol>
<li>В случае объявления переменной в теле метода время на выделение места под структуру можно считать около нулевым. Ведь время на выделение места под локальные переменные почти не зависит от их количества;</li>
<li>В случае размещения ValTypes в качестве полей RefTypes просто увеличит их размер. Значимый тип размещается целиком, становясь его частью;</li>
<li>Если ValTypes передаются как параметры метода &mdash; тут, как и в случае копирования, возникнет некоторая разница &mdash; в зависимости от размера и положения параметра.</li>
</ol>
<p>Но в любом случае это не дольше копирования из одной переменной в другую.</p>
<h2 id="classstruct">Особенности выбора между class/struct</h2>
<p>Давайте подумаем об особенностях обоих типов, об их достоинствах и недостатках и решим, где ими лучше пользоваться. Тут, конечно же, стоит вспомнить классиков, дающих утверждение, что выбор в сторону значимых типов стоит сделать, если у нас тип не планирует быть наследуемым, он не станет меняться в течении своей жизни, а его размер не превышает 16 байт. Но не все так очевидно. Чтобы сделать полноценное сравнение, нам необходимо задуматься о выборе типа с разных сторон, мысленно продумав сценарии его будущего использования. Предлагаю разделить критерии выбора на три группы:</p>
<ul>
<li>с точки зрения архитектуры системы типов, в которой ваш тип будет взаимодействовать;</li>
<li>с точки зрения подхода вас как системного программиста: каков выбор будет оптимальным с точки зрения производительности;</li>
<li>по-другому просто невозможно.</li>
</ul>
<p>Каждая сущность, которая проектируется вами, должна в полной мере отражать её назначение. И это касается не только её названия или интерфейса взаимодействия (методы, свойства), но даже выбор между значимым и ссылочным типом может быть сделан из архитектурных соображений. Давайте порассуждаем, почему с точки зрения архитектуры системы типов может быть выбрана структура, а не класс:</p>
<ol>
<li><p>Если наш проектируемый тип будет обладать инвариантностью по отношению к смысловой нагрузке своего состояния, то это будет значить, что его состояние полностью отражает некоторый процесс или является значением чего-либо. Другими словами, экземпляр типа полностью константен и не может быть изменён по своей сути. Мы можем создать на основе этой константы другой экземпляр типа, указав некоторое смещение, либо создать с нуля, указав его свойства. Но изменять его мы не имеем права. Я прошу заметить, что не подразумеваю структуру неизменяемым типом. Вы можете менять поля, как хотите. Мало того вы можете отдать ссылку на структуру в метод через <code>ref</code> параметр и получить изменённые поля по выходу из метода. Однако, я про смысл с точки зрения архитектуры. Поясню на примерах:</p>
<ul>
<li>DateTime &mdash; это структура, которая инкапсулирует в себе понятие момента времени. Она хранит эти данные в виде <code>uint</code>, однако предоставляет доступ к отдельным характеристикам момента времени. Например: год, месяц, день, час, минуты, секунды, миллисекунды и даже процессорные тики. Однако, исходя из того что она инкапсулирует, она не может быть изменяемой по своей природе. Мы не можем изменить конкретный момент времени, чтобы он стал другим. Я не могу прожить следующую минуту своей жизни в лучший день рождения своего детства. Время неизменно. Именно поэтому выбор для типа данных может стать либо класс с readonly интерфейсом взаимодействия, который на каждое изменение свойств отдаёт новый экземпляр, либо структура, которая, несмотря на возможность изменения полей своих экземпляров делать этого не должна: описание момента времени является <em>значением</em>. Как число. Вы же не можете залезть в структуру числа и поменять его? Если вы хотите получить другой момент времени, который является смещением относительно оригинального на один день, вы просто получаете новый экземпляр структуры;</li>
<li>KeyValuePair&lt;TKey, TValue&gt; &mdash; это структура, инкапсулирующая в себе понятие связной пары ключ-значение. Замечу, что эта структура используется только для выдачи пользователю при перечислении содержимого словаря. Почему выбрана структура с точки зрения архитектуры? Ответ прост: потому что в рамках Dictionary<T> ключ и значение, неразделимые понятия. Да, внутри все устроено иначе. Внутри мы имеем сложную структуру, где ключ лежит отдельно от значения. Однако для внешнего пользователя, с точки зрения интерфейса взаимодействия и смысла самой структуры данных, пара ключ-значение является неразделимым понятием. Является <em>значением</em> целиком. Если мы по этому ключу расположили другое значение, это значит, что изменилась вся пара. Для внешнего наблюдателя нет отдельно ключей, а отдельно &mdash; значений, они являются единым целым. Именно поэтому структура в данном случае &mdash; идеальный вариант.</li>
</ul>
</li>
<li><p>Если наш проектируемый тип является неотъемлемой частью внешнего типа. Но при этом он структурно неотъемлем. Т.е. было бы некорректным сказать, что внешний тип ссылается на экземпляр инкапсулируемого, но совершенно корректно &mdash; что инкапсулируемый является полноправной частью внешнего вместе со всеми своими свойствами. Как правило, это используется при проектировании структур, которые являются частью другой структуры.</p>
<ul>
<li>Как, например, если взять структуру заголовка файла, было бы нечестно дать ссылку из одного файла в другой. Мол, заголовок находится в файле <code>header.txt</code>. Это было бы уместно при вставке документа в некий другой, но не вживанием файла, а по относительной ссылке на файловой системе. Хороший пример &mdash; файл ярлыка ОС Windows. Однако если мы говорим о заголовке файла (например, о заголовке JPEG файла, в котором указаны размер изображения, методика сжатия, параметры съёмки, координаты GPS и прочая метаинформация), то при проектировании типов, которые будут использованы для парсинга заголовка, будет крайне полезно использовать структуры. Ведь, описав все заголовки в структурах, вы получите в памяти абсолютно такое же положение всех полей как в файле. И через простое unsafe преобразование <code>*(Header *)readedBuffer</code> без каких-либо десериализаций &mdash; полностью заполненные структуры данных.</li>
</ul>
</li>
<li><p>При этом заметьте, ни один из примеров не обладает свойством наследования поведения чего-либо. Мало того все эти примеры также показывают, что нет абсолютно никакого смысла наследовать поведение этих сущностей. Они полностью самодостаточны, как единицы чего-либо.</p>
</li>
</ol>
<p>Если же мы взглянем на проблематику с точки зрения эффективности работы кода, то перед нами выбор предстанет с другой стороны:</p>
<ol>
<li>Структуры необходимо выбирать, если необходимо забрать из неуправляемого кода какие-то структурированные данные. Либо отдать unsafe методу структуру данных. Ссылочный тип для этого совсем не подойдёт;</li>
<li>Если тип будет часто использоваться для передачи данных в вызовах методов (пусть в качестве возвращаемых значений или как параметр метода), но при этом нет никакой необходимости ссылаться на одно значение с разных мест, то ваш выбор &mdash; структура. Как пример я могу привести кортежи. Если метод через кортеж возвращает вам несколько значений, это значит, что возвращать он будет ValueTuple, который объявлен как структура. Т.е. при возврате метод не будет выделять память в куче, а использовать он будет стек потока, выделение памяти в котором не стоит вам абсолютно ничего;</li>
<li>Если вы проектируете систему, которая создаёт некий больший трафик экземпляров проектируемого типа. При этом сами экземпляры имеют достаточно малый размер, а время жизни экземпляров очень короткое, то использование ссылочных типов приведёт либо к использованию пула объектов, либо, если без пула, к неконтролируемому замусориванию кучи. При этом часть объектов перейдёт в старшие поколения, чем вызовет проседание на GC. Использование значимых типов в таких местах (если это возможно) даст прирост производительности просто потому, что в SOH ничего не уйдёт, а это разгрузит GC, и алгоритм отработает быстрее;</li>
</ol>
<p>Совмещая все вышесказанное, могу предложить некоторые советы и замечания в использовании структур:</p>
<ol>
<li>При выборе коллекций стоит избегать больших массивов, внутри которых находятся большие структуры. Это касается и тех структур данных, которые на массивах основаны (а их &mdash; большинство). Это может привести к уходу в Large Objects Heap и его фрагментации. Мало подсчитать, что, если у вашей структуры 4 поля типа byte, значит, займёт она 4 байта. Вовсе нет. Надо понимать, что для 32-разрядных систем каждое поле структуры будет выровнено по 4 байтам (адрес каждого поля должен делиться на 4 без остатка), а на 64-разрядных системах &mdash; по 8 байтам. Т.е. размер массива должен зависеть от размера структуры и от платформы, на которой запущено приложение. В нашем примере с 4 байтами &mdash; 85К / (от 4 до 8 байт на поле * количество полей = 4) минус размер заголовка массива: примерно до 2600 элементов на массив в зависимости от платформы (а брать понятное дело надо в меньшую сторону). Всего-то! Не так и много! А ведь могло показаться, что магическая константа в 20,000 элементов вполне могла подойти!</li>
<li>Также стоит отдавать себе отчёт, что если вы используете структуру, которая имеет некоторый достаточно большой размер, как источник данных, и размещаете её в некотором классе как поле, и при этом, например, одна и та же копия растиражирована на тысячу экземпляров (просто потому, что вам удобно держать все под рукой), то вы тем самым увеличиваете каждый экземпляр класса на размер структуры, что в конечном счёте приведёт к распуханию 0-го поколения и уходу в поколение 1 или даже 2. При этом если на самом деле экземпляры класса короткоживущие, и вы рассчитываете на то, что они будут собраны GC в нулевом поколении &mdash; за 1 мс, то будете сильно разочарованы тем, что они на самом деле успели попасть в первое или даже во второе поколение. А какая, собственно, разница? Разница в том, что если поколение 0 собирается за 1 мс, то первое и второе &mdash; очень медленно, что приведёт к проседаниям на пустом месте;</li>
<li>По примерно той же причине стоит избегать проброса больших структур через цепочку вызовов методов. Потому как если все начнёт друг друга вызывать, то такие вызовы займут намного больше места в стеке, подводя жизнь вашего приложения к смерти через <code>StackOverflowException</code>. Вторая причина &mdash; производительность. Чем больше копирований, тем медленнее все работает;</li>
</ol>
<p>Потому в целом выбор между типами данных &mdash; достаточно нетривиальный процесс. Зачастую это может относиться к преждевременной оптимизации, чего делать не рекомендуется. Однако, если вы знаете, что ваша ситуация попадает под выше изложенные принципы, то можете спокойно делать выбор в сторону значимого типа.</p>
<h2 id="object.boxing">Базовый тип &mdash; Object и возможность реализации интерфейсов. Boxing.</h2>
<p>Мы с вами прошли, как может показаться и огонь, и воду и можем пройти любое собеседование. Возможно даже в команду .NET CLR. Но давайте не будем спешить набирать microsoft.com и искать там раздел вакансий: успеем. Давайте лучше ответим на такой вопрос. Если значимые типы не содержат ни ссылки на SyncBlockIndex, ни указателя на таблицу виртуальных методов... То, простите, как они наследуют тип <code>object</code>? Ведь по всем канонам любой тип наследует именно его. Ответ на этот вопрос к сожалению не будет вмещён в одно предложение, но даст такое понимание о нашей системе типов, что последние кусочки пазла наконец встанут на свои места.</p>
<p>Итак, давайте ещё раз вспомним про размещение значимых типов в памяти. Везде, где бы они ни находились, они вживляются в то место, где находятся. Они становятся его частью. В отличии от ссылочных типов, для которых закон твердит быть в куче малых или больших объектов, а в место установки значения &mdash; всегда ставить ссылку на место в куче, где расположился наш объект.</p>
<p>Так вот если задуматься, то у любого значимого типа есть методы <code>ToString</code>, <code>Equals</code> и <code>GetHashCode</code>, которые являются виртуальными, переопределяемыми, но нам не дают наследовать значимые типы, переопределяя методы. Почему? Потому что если значимые типы сделать с переопределяемыми методами, то им понадобится таблица виртуальных методов, через которую будет осуществляться роутинг вызовов. А это в свою очередь повлечёт за собой проблемы проброса структур в unmanaged мир: туда уйдут лишние поля. В итоге получается, что описание методов значимых типов где-то лежат, но к ним нет прямого доступа через таблицу виртуальных методов.</p>
<p>Это наводит на мысль что отсутствие наследования искусственно:</p>
<ul>
<li>Наследование от object есть, хоть и не прямое;</li>
<li>В базовом типе есть ToString, Equals и GetHashCode, которые по-своему работают в значимых типах: у этих методов своё поведение в каждом из них. А значит, что методы переопределены относительно object;</li>
<li>более того, если вы сделаете приведение типа в <code>object</code>, вы все ещё можете на полных правах вызывать ToString, Equals и GetHashCode.</li>
<li>При вызове экземплярного метода над значимым типом не происходит копирования в метод. Т.е. вызов экземплярного метода аналогичен вызову статического метода: <code>Method(ref structInstance, newInternalFieldValue)</code>. А это ведь, по сути, вызов с передачей <code>this</code> за одним исключением: JIT должен собрать тело метода так, чтобы не делать дополнительного смещения на поля структуры, перепрыгивая через указатель на таблицу виртуальных методов, которой в самой структуре нет. <em>Для значимых типов она находится в другом месте</em>.</li>
</ul>
<p>Т.е. в некотором смысле нас не то чтобы обманывают, но недоговаривают: типы сильно отличаются поведенчески, но на уровне реализации в CLR разница между ними не столь существенна. Но об этом немного позже.</p>
<p>Если мы напишем следующую строчку в нашей программе:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> obj = (<span style="color:Blue;">object</span>)10;
</pre></div>
</div>
<p>То мы перестанем иметь дело с числом <code>10</code>. Произойдёт так называемый boxing: упаковка. Т.е. мы начнём иметь возможность работать с ним через базовый класс. А если мы получили такие возможности, это значит, что нам стала доступна VMT, через которую можно спокойно вызывать виртуальные методы ToString(), Equals и GetHashCode. Причём поскольку оригинальное значение у нас может храниться где угодно: хоть на стеке, хоть как поле класса, а приводя к типу <code>object</code> мы получаем возможность хранить ссылку на это число веки вечные, то в реальности boxing создаёт копию значимого типа, а не делает указатель на оригинал. Т.е. когда происходит boxing, то:</p>
<ul>
<li>CLR выделяет место в куче под структуру + SyncBlockIndex + VMT значимого типа (чтобы иметь возможность вызвать ToString, GetHashCode, Equals);</li>
<li>копирует туда экземпляр значимого типа.</li>
</ul>
<p>Дамы и господа. В приличном обществе такое не принято говорить, но мы получили ссылочный вариант значимого типа. Я повторю ещё раз: совершив boxing структура получила <strong>абсолютно такой же набор системных полей, что и ссылочный тип</strong>, став полноценным ссылочным типом. Структура стала классом. Давайте назовём это явление Кульбит Дотнетского. Мне кажется, это название будет достойным такого хитрого поворота дел.</p>
<p>Кстати, чтобы вы поверили в честность моих слов, достаточно разобраться, что происходит если вы используете структуру, которая реализует некий интерфейс &mdash; по этому самому интерфейсу.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Blue;">struct</span> Foo : IBoo
{
    <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">void</span> Boo()
    {
        x = 666;
    }
}

IBoo boo = <span style="color:Blue;">new</span> Foo();

boo.Boo();

</pre></div>
</div>
<p>Итак, когда создаётся экземпляр Foo, то его значение, по сути, находится на стеке. После чего мы кладём эту переменную в переменную интерфейсного типа. Структуру &mdash; в переменную ссылочного типа. Происходит <code>boxing</code>. Хорошо. На выходе мы получили тип <code>object</code>. Но переменная у нас &mdash; интерфейсного типа. А это значит, что необходимо преобразование типа. Т.е. вызов, скорее, происходит как-то так:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

IBoo boo = (IBoo)(box_to_object)<span style="color:Blue;">new</span> Foo();
boo.Boo();

</pre></div>
</div>
<p>Т.е. написание такого кода &mdash; это крайне не эффективно. Мало того что вы будете менять копию вместо оригинала:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Main()
{
    <span style="color:Blue;">var</span> foo = <span style="color:Blue;">new</span> Foo();
    foo.a = 1;
    Console.WriteLite(foo.a);  <span style="color:Green;">// -&gt; 1</span>
    
    IBoo boo = foo;
    boo.Boo();                 <span style="color:Green;">// выглядит как изменение foo.a на 10</span>
    Console.WriteLite(foo.a);  <span style="color:Green;">// -&gt; 1</span>
}

<span style="color:Blue;">struct</span> Foo : IBoo 
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> a;
    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Boo()
    {
        a = 10;
    }
}

<span style="color:Blue;">interface</span> IBoo 
{
    <span style="color:Blue;">void</span> Boo();
}
</pre></div>
</div>
<p>Выглядит как обман дважды. Первый раз &mdash; глядя на код мы не обязаны знать, с чем имеем дело в <em>чужом</em> коде, и видим ниже приведение к интерфейсу <code>IBoo</code>. Что фактически гарантированно наводит нас на мысль, что Foo &mdash; класс, а не структура. Далее &mdash; полное отсутствие визуального разделения на структуры и классы даёт полное ощущение, что результаты модификации по интерфейсу обязаны попасть в foo, чего не происходит потому, что boo &mdash; копия foo. Что фактически вводит нас в заблуждение. На мой взгляд, такой код стоит снабжать комментариями, чтоб внешний разработчик смог бы в нем правильно разобраться.</p>
<p>Второе наблюдение, связанное с нашими, более ранними рассуждениями, а именно с тем, что мы можем сделать приведение типа из <code>object</code> в <code>IBoo</code>. Это &mdash; ещё одно доказательство, что boxed значимый тип не что-то особенное, а на самом деле ссылочный вариант значимого типа. Либо если посмотреть с другого угла &mdash; все типы в системе типов являются ссылочными. Просто со структурами мы можем работать как со значимыми, &laquo;отгружая&raquo; их значение целиком. Как бы сказали в мире C++, разыменовывая указатель на объект.</p>
<p>Но вы можете возразить: дескать, если бы все было именно так, как я говорю, то можно было бы написать как-то так:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> referenceToInteger = (IInt32)10;
</pre></div>
</div>
<p>И мы получили бы не просто <code>object</code>, а типизированную ссылку на упакованный значимый тип. Но тогда бы это разрушило всю идею значимых типов, друзья. А основная идея &mdash; это целостность их значения, позволяющее делать отличные оптимизации, основываясь на их свойствах. Так не будем сидеть сложа руки! Давайте разрушим эту идею!</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">sealed</span> <span style="color:Blue;">class</span> Boxed&lt;T&gt;
{
    <span style="color:Blue;">public</span> T Value;
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">override</span> <span style="color:Blue;">bool</span> Equals(<span style="color:Blue;">object</span> obj)
    {
        <span style="color:Blue;">return</span> Value.Equals(obj);
    }
        
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">override</span> <span style="color:Blue;">string</span> ToString()
    {
        <span style="color:Blue;">return</span> Value.ToString();
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">override</span> <span style="color:Blue;">int</span> GetHashCode()
    {
        <span style="color:Blue;">return</span> Value.GetHashCode();
    }
}
</pre></div>
</div>
<p>Что мы только что получили? Мы получили абсолютно полный аналог боксинга. Но теперь у нас есть возможность менять его содержимое путём вызова его экземплярных методов. И эти изменения получат все, у кого будет ссылка на эту структуру данных.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> typedBoxing = <span style="color:Blue;">new</span> Boxed&lt;<span style="color:Blue;">int</span>&gt; { Value = 10 };
<span style="color:Blue;">var</span> pureBoxing = (<span style="color:Blue;">object</span>)10;
</pre></div>
</div>
<p>Первый вариант, согласитесь, выглядит несколько неуверенно. Вместо привычного приведения типа мы городим не пойми что. То ли дело вторая строчка. Лаконична как японский стих. Однако они на самом деле почти полностью идентичны. Разница состоит только в том, что во время обычной упаковки после выделения памяти в куче не происходит очистки памяти нулями: память сразу занимается необходимой структурой. Тогда как в первом варианте очистка есть. Только из-за этого наш вариант медленнее обычной упаковки на 10%.</p>
<p>Зато теперь мы можем вызывать у нашего упакованного значения какие-то методы:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">struct</span> Foo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">int</span> newx)
    {
        x = newx;
    }
}

<span style="color:Blue;">var</span> boxed = <span style="color:Blue;">new</span> Boxed&lt;Foo&gt; { Value = <span style="color:Blue;">new</span> Foo { x = 5 } };
boxed.Value.ChangeTo(10);
<span style="color:Blue;">var</span> unboxed = boxed.Value;
</pre></div>
</div>
<p>Мы получили новый инструмент, но пока не знаем, что с ним делать. Давайте добьёмся ответа рассуждениями:</p>
<ul>
<li>Наш тип <code>Boxed&lt;T&gt;</code> по сути, осуществляет все то же самое, что и обычный: выделяет память в куче, отдаёт туда значение и позволяет его забрать, выполнив своеобразный <code>unbox</code>;</li>
<li>Точно также, если потерять ссылку на упакованную структуру, GC её соберёт;</li>
<li>Однако у нас теперь есть возможность работы с упакованным типом: вызывать у него методы;</li>
<li>Также теперь мы имеем возможность подменить экземпляр значимого типа в SOH/LOH на другой. Этого мы не могли сделать раньше: нам пришлось бы делать <code>unboxing</code>, менять структуру на другую и делать <code>boxing</code> обратно, раздав новую ссылку потребителям.</li>
</ul>
<p>Также давайте подумаем, какая основная проблема у упаковки? Создание трафика в памяти. Трафика непонятного количества объектов, часть из которых может выжить до первого поколения, где мы получим проблемы со сборкой мусора: он там будет, его там будет много, и этого явно можно было избежать. А когда мы имеем трафик короткоживущих объектов, первое решение, которое приходит в голову, &mdash; пуллинг. Вот это будет отличным завершением Кульбита Дотнетского.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> pool = <span style="color:Blue;">new</span> Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000);
<span style="color:Blue;">var</span> boxed = pool.Box(10);
boxed.Value=70;

<span style="color:Green;">// use boxed value here</span>

pool.Free(boxed);
</pre></div>
</div>
<p>Т.е. мы получили возможность работы боксинга через пул, тем самым удалив трафик памяти по части боксинга до нуля. Шутки ради можно даже сделать, чтобы в методе финализации объекты воскрешали бы себя, засовывая обратно в пул объектов. Это пригодилось бы для ситуаций, когда <code>boxed</code> структура уходит в чужой асинхронный код и нет возможности понять, когда она стала не нужна. В этом случае она сама себя вернёт в пул во время GC.</p>
<p>А теперь давайте сделаем выводы:</p>
<ul>
<li>Если упаковка &mdash; случайна и такого не должно было произойти, будьте аккуратны и не допускайте её возникновения: она может привести к проблемам производительности;</li>
<li>Если упаковка &mdash; дань требованиям архитектуры той системы, которую вы делаете, то тут могут возникнуть варианты: если трафик упакованных структур мал, и не заметен, можно не обращать никакого внимания и работать через упаковку. Если же трафик становится заметным, то возможно стоит сделать пуллинг боксинга через решение, указанное выше. Да, оно даёт некоторые расходы на производительности пуллинга, зато GC спокоен и не работает на износ;</li>
</ul>
<p>Напоследок, давайте рассмотрим пример из мира совершенно не практичного кода</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">static</span> <span style="color:Blue;">unsafe</span> <span style="color:Blue;">void</span> Main()
{
    <span style="color:Green;">// делаем boxed int</span>
    <span style="color:Blue;">object</span> boxed = 10;

    <span style="color:Green;">// забираем адрес указателя на VMT</span>
    <span style="color:Blue;">var</span> address = (<span style="color:Blue;">void</span>**)EntityPtr.ToPointerWithOffset(boxed);

    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Green;">// забираем адрес Virtual Methods Table</span>
        <span style="color:Blue;">var</span> structVmt = <span style="color:Blue;">typeof</span>(SimpleIntHolder).TypeHandle.Value.ToPointer();

        <span style="color:Green;">// меняем адрес VMT целого числа, ушедшего в Heap на VMT SimpleIntHolder, превратив Int в структуру</span>
        *address = structVmt;
    }

    <span style="color:Blue;">var</span> structure = (IGetterByInterface)boxed;

    Console.WriteLine(structure.GetByInterface());
}

<span style="color:Blue;">interface</span> IGetterByInterface
{
    <span style="color:Blue;">int</span> GetByInterface();
}

<span style="color:Blue;">struct</span> SimpleIntHolder : IGetterByInterface
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> value;

    <span style="color:Blue;">int</span> IGetterByInterface.GetByInterface()
    {
        <span style="color:Blue;">return</span> value;
    }
}
</pre></div>
</div>
<p>Этот код написан при помощи маленькой функции, которая умеет получать указатель из ссылки на объект. Библиотека находится <a href="https://github.com/mumusan/dotnetex/blob/master/libs/">по адресу на github</a>. Этот код показывает, что обычный boxing превращает int в типизированный reference type. Рассмотрим его по шагам:</p>
<ol>
<li>Делаем boxing для целого числа</li>
<li>Достаём адрес полученного объекта (по этому адресу находится VMT Int32)</li>
<li>Получаем VMT структуры SimpleIntHolder</li>
<li>Подменяем VMT запакованного целого числа на VMT структуры</li>
<li>Делаем unbox в тип структуры</li>
<li>Выводим значение поля &mdash; на экран, доставая тем самым тот Int32, который был изначально запакован.</li>
</ol>
<p>Причём заметьте, что делаю я это намеренно через интерфейс, показав, что так тоже будет работать.</p>
<h3 id="nullablet">Nullable&lt;T&gt;</h3>
<p>Также стоит сказать про то, как ведёт себя <code>boxing</code> для Nullable значимых типов. Это очень приятная особенность Nullable значимых типов, поскольку boxing значимого типа, который как бы null &mdash; просто возвратит null:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span>? x = 5;
<span style="color:Blue;">int</span>? y = <span style="color:Blue;">null</span>;

<span style="color:Blue;">var</span> boxedX = (<span style="color:Blue;">object</span>)x; <span style="color:Green;">// -&gt; 5</span>
<span style="color:Blue;">var</span> boxedY = (<span style="color:Blue;">object</span>)y; <span style="color:Green;">// -&gt; null</span>
</pre></div>
</div>
<p>Отсюда следует забавный вывод: т.к. null не имеет типа, то единственный вариант вытащить из boxing'a другой тип, нежели был запакован, такой:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span>? x = <span style="color:Blue;">null</span>;
<span style="color:Blue;">var</span> pseudoBoxed = (<span style="color:Blue;">object</span>)x;
<span style="color:Blue;">double</span>? y = (<span style="color:Blue;">double</span>?)pseudoBoxed;
</pre></div>
</div>
<p>Код рабочий просто потому, что с null можно сделать приведение типа куда угодно. Но зато таким кодом можно запросто удивить своих коллег и скрасить вечер забавным фактом.</p>
<h2 id="boxing">Погружаемся в boxing ещё глубже</h2>
<p>На закуску хочу вам рассказать про тип <a href="http://referencesource.microsoft.com/#mscorlib/system/enum.cs,36729210e317a805">System.Enum</a>. Не проходя по ссылке, скажите, пожалуйста, является ли тип Value Type или же Reference Type? По всем канонам и логике тип просто обязан быть значимым. Ведь это обычное перечисление: набор aliases с чисел на названия в языке программирования. И мы бы закончили этот разговор словами: &laquo;вы все думаете абсолютно правильно! Так не будем терять времени и пойдём дальше!&raquo;, &mdash; но нет. <code>System.Enum</code>, от которого наследуются все <code>enum</code> типы данных, определённых как в вашем коде, так и в .NET Framework, является ссылочным типом. Т.е. типом данных <code>class</code>. Мало того (!) класс этот абстрактный и наследуется от <code>System.ValueType</code>.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(<span style="color:Blue;">true</span>)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">abstract</span> <span style="color:Blue;">class</span> Enum : ValueType, IComparable, IFormattable, IConvertible
    {
        <span style="color:Green;">// ...</span>
    }
</pre></div>
</div>
<p>Значит ли это, что все перечисления выделяются в куче SOH? Значит ли это, что, используя перечисления, мы забиваем кучу, а вместе и с ней &mdash; GC? Ведь мы просто используем их. Нет, такого не может быть. Тогда, получается, что есть где-то пул перечислений, в которых они лежат, и что нам отдаются их экземпляры. И снова нет: перечисления можно использовать в структурах при маршаллинге. Перечисления &mdash; обычные числа.</p>
<p>А правда заключается в том, что CLR при формировании структур типа данных прямо скажем подхачивает её, если встречается <code>enum</code> <a href="https://github.com/dotnet/coreclr/blob/4b49e4330441db903e6a5b6efab3e1dbb5b64ff3/src/vm/methodtablebuilder.cpp#L1425-L1445">превращая класс в значимый тип</a>:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Check to see if the class is a valuetype; but we don&#39;t want to mark System.Enum</span>
<span style="color:Green;">// as a ValueType. To accomplish this, the check takes advantage of the fact</span>
<span style="color:Green;">// that System.ValueType and System.Enum are loaded one immediately after the</span>
<span style="color:Green;">// other in that order, and so if the parent MethodTable is System.ValueType and</span>
<span style="color:Green;">// the System.Enum MethodTable is unset, then we must be building System.Enum and</span>
<span style="color:Green;">// so we don&#39;t mark it as a ValueType.</span>
<span style="color:Blue;">if</span>(HasParent() &amp;&amp;
    ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) ||
    GetParentMethodTable() == g_pEnumClass))
{
    bmtProp-&gt;fIsValueClass = <span style="color:Blue;">true</span>;

    HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(),
                                                            g_CompilerServicesUnsafeValueTypeAttribute,
                                                            NULL, NULL);
    IfFailThrow(hr);
    <span style="color:Blue;">if</span> (hr == S_OK)
    {
        SetUnsafeValueClass();
    }
}
</pre></div>
</div>
<p>Зачем это делается? В частности из-за идеи наследования: чтобы сделать пользовательский <code>enum</code>, необходимо снабдить его информацией об именах его возможных значений, например. А как сделать наследование у значимых типов? Никак. Вот и придумали они сделать его ссылочным, но на этапе работы JIT превращать его в значимый. Чтобы никто не догадался.</p>
<h2 id="boxing-1">Что если хочется лично посмотреть как работает boxing?</h2>
<p>В наше время для того чтобы посмотреть на реализацию упаковки значимых типов, к счастью, нет необходимости загружать дизассемблер и лезть в самые дебри не пойми чего. В наше прекрасное время у нас есть исходные тексты всего ядра платформы .NET и многие его части абсолютно идентичны между .NET Framework CLR и CoreCLR. Вы можете пройти по ссылкам ниже и посмотреть на реализации упаковки прямо в исходных кодах:</p>
<ul>
<li>Существует отдельная группа оптимизаций, каждая из которых используется на отдельном типе процессора:
<ul>
<li><em><a href="https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/JitHelpers_InlineGetThread.asm#L86-L148">JIT_BoxFastMP_InlineGetThread</a></em> (AMD64 &mdash; многопроцессорный или Server GC, implicit Thread Local Storage)</li>
<li><em><a href="https://github.com/dotnet/coreclr/blob/8cc7e35dd0a625a3b883703387291739a148e8c8/src/vm/amd64/JitHelpers_Slow.asm#L201-L271">JIT_BoxFastMP</a></em> (AMD64 &mdash; многопроцессорный или Server GC)</li>
<li><em><a href="https://github.com/dotnet/coreclr/blob/8cc7e35dd0a625a3b883703387291739a148e8c8/src/vm/amd64/JitHelpers_Slow.asm#L485-L554">JIT_BoxFastUP</a></em> (AMD64 &mdash; однопроцессорный или Workstation GC)</li>
<li><em><a href="https://github.com/dotnet/coreclr/blob/38a2a69c786e4273eb1339d7a75f939c410afd69/src/vm/i386/jitinterfacex86.cpp#L756-L886">JIT_TrialAlloc::GenBox(..)</a></em> (x86), которая присоединяется через JitHelpers</li>
</ul>
</li>
<li>В общем случае JIT инлайнит вызов вспомогательной функции <a href="https://github.com/dotnet/coreclr/blob/a14608efbad1bcb4e9d36a418e1e5ac267c083fb/src/jit/importer.cpp#L5212-L5221">Compiler::impImportAndPushBox(..)</a></li>
<li>Generic-версия, использует менее оптимизированную <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.cpp#L3734-L3783">MethodTable::Box(..)</a>
<ul>
<li>И наконец вызывается <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581">CopyValueClassUnchecked(..)</a>, по коду которой прекрасно видно, почему лучше всего выбирать размер структур до 8 байт включительно.</li>
</ul>
</li>
</ul>
<p>Для сравнения чтобы сделать распаковку реализован всего один метод: <em><a href="https://github.com/dotnet/coreclr/blob/03bec77fb4efaa397248a2b9a35c547522221447/src/vm/jithelpers.cpp#L3603-L3626">JIT_Unbox(..)</a></em>, который является обёрткой вокруг <em><a href="https://github.com/dotnet/coreclr/blob/03bec77fb4efaa397248a2b9a35c547522221447/src/vm/jithelpers.cpp#L3574-L3600">JIT_Unbox_Helper(..)</a></em>.</p>
<p>Также <a href="https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right">интересным фактом является то</a>, что сам процесс распаковки не является копированием данных из кучи: распаковка является передачей указателя на кучу с проверкой совместимости типов. А вот следующий за распаковкой опкод IL определит, что будет с этим адресом: возможно, данные будут скопированы в локальную переменную, а может быть &mdash; скопированы в стек для вызова метода. Ведь если бы это было не так, мы бы имели дело с двойным копированием: сначала при копировании куда-то из кучи, а затем &mdash; при копировании в место назначения.</p>
<h2 id="ref">Ключевое слово ref</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="spant-memoryt">Span&lt;T&gt;, Memory&lt;T&gt;</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="makeref_reftype_refvalue_arglist">__makeref, __reftype, __refvalue, __arglist</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="boxing-2">Неявный Boxing</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h3 id="section-6">Раздел вопросов по теме</h3>
<h2 id="net-clr">Почему .NET CLR не делает пуллинга для боксинга самостоятельно?</h2>
<p>Если мы поговорим с любым Java разработчиком, то мы с удивлением узнаем две вещи:</p>
<ul>
<li>В Java все Value Types запакованы и по сути не являются значимыми. Т.е. целые числа &mdash; тоже запакованы;</li>
<li>Для оптимизации числа от -128 до 127 берутся из пула объектов.</li>
</ul>
<p>Так почему же в .NET CLR во время упаковки не происходит того же самого? Ответ прост: потому что мы можем менять содержимое упакованного значимого типа. Т.е. другими словами, мы можем сделать так:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">object</span> x = 1;
x.GetType().GetField(<span style="color:#A31515;">&quot;m_value&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138);
Console.WriteLine(x); <span style="color:Green;">// -&gt; 138</span>
</pre></div>
</div>
<p>или так (С++/CLI):</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> ChangeValue(Object^ obj)
{
    Int32^ i = (Int32^)obj;
    *i = 138;
}
</pre></div>
</div>
<p>Т.е. если бы мы имели дело с пуллингом, то мы бы поменяли все единицы в приложении на 138! Согласитесь, ситуация не из приятных.</p>
<p>Вторая причина &mdash; это сама суть значимых типов в .NET. Они работают по значению, а значит &mdash; быстрее. Упаковка для нас &mdash; редкая операция и сложение упакованных чисел &mdash; это скорее что-то из фантастики и очень плохой архитектуры. Это просто не будет чем-то хоть как-то полезным, чтобы заниматься реализацией данного функционала.</p>
<h2 id="object-boxing">Почему при вызове метода, принимающего тип object, а по факту &mdash; значимый тип нет возможности сделать boxing на стеке, разгрузив кучу?</h2>
<p>Потому что если произойдёт упаковка значимого типа на стеке, после чего ссылка уйдёт в кучу, то внутри метода ссылка может уйти в какое-либо другое место, например метод может записать пришедшую ссылку в поле какого-либо класса. Далее метод завершит работу, после чего завершит работу метод, который сделал упаковку. Как результат &mdash; с внешнего класса ссылка будет указывать на &laquo;вымерший&raquo; участок стека.</p>
<h2 id="value-type">Почему нельзя использовать в качестве поля Value Type его самого?</h2>
<p>Иногда возникает дерзкое желание в качестве поля структуры использовать другую структуру, которая использует первую. Или же ещё проще: В качестве поля структуры использовать её саму. Не задавайте мне вопросов, почему такое может понадобиться: на самом деле не может :) Но почему так сделать нельзя? Ответ прост: когда вы используете структуру в качестве поля её же самой либо через зависимость от другой структуры, то фактически создаёте рекурсию: вы создаёте структуру бесконечных размеров. Однако, в .NET Framework есть места, в которых так сделано. Примером может служить структура <code>System.Char</code>, <a href="http://referencesource.microsoft.com/#mscorlib/system/char.cs,02f2b1a33b09362d">которая содержит саму себя</a>:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">struct</span> Char : IComparable, IConvertible
{
    <span style="color:Green;">// Member Variables</span>
    <span style="color:Blue;">internal</span> <span style="color:Blue;">char</span> m_value;
    <span style="color:Green;">//...</span>
}
</pre></div>
</div>
<p>Кстати говоря, так сделаны практически все примитивные типы CLR. Нам смертным так сделать невозможно, да и нет никакой надобности: в CLR это сделано, чтобы добавить примитивным типам дух ООП.</p>
<h2 id="section-7">Ссылки</h2>
<ul>
<li><a href="https://github.com/mumusan/dotnetex/blob/master/libs/">Библиотечка для получения чистого указателя на объект</a></li>
</ul>
<blockquote>
<p>Далее: <a href="./2-ObjectsStructure.html">Структура объектов в памяти</a></p>
</blockquote>

</div>
</div>
</body>
</html>